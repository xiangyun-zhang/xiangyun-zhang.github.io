{"pages":[{"title":"","text":"Xiangyun’s Blog作为文章记录、更新和备份的私有库，只保证文章备份，博客框架、主题修改等记录在 blog 仓库中。","link":"/readme"},{"title":"","text":"","link":"/about/"}],"posts":[{"title":"Xiangyun&#39;s Blog 重新连接","text":"Hello world！Hello Hexo！ 兜兜转转，最后还是通过 Github Pages和 Hexo 搭建了个人博客。不过 Github Pages 中国大陆访问越来越不稳定了，也考虑把博客部署到 Gitee 上，有空再研究。 虽然放在 Github，但是博客并不打算局限于做技术博客，而是想写什么就写什么，风格不限、体裁不限、内容不限。 博客还有很多要完善的地方，即便是 Hexo 的静态页面，但是看上去还是有特别多的地方值得研究，慢慢来吧。 距离2022只剩下的小半年，但仍旧能够惊艳。","link":"/2021-9f238081d6ce/"},{"title":"2021年书单目录","text":"封面 信息 进度 《一句顶一万句》 作者：刘震云 出版社：长江文艺出版社 https://book.douban.com/subject/26877012/ - 《虚拟偶像爱朵露》 作者：[美] 威廉·吉布森 出版社：新星出版社 https://book.douban.com/subject/25725500/ - 《雪崩》 作者：[美] 尼尔·斯蒂芬森 出版社：四川科学技术出版社 https://book.douban.com/subject/27097409/ - 《富野由悠季的影像原则》 作者： [日] 富野由悠季 出版社：浙江大学出版社 https://book.douban.com/subject/35349490/ 第四章读完， 共十二章 《故事》 作者：[美] 罗伯特·麦基 出版社: 天津人民出版社 https://book.douban.com/subject/25976544/ 第一章在读","link":"/2021-59df9e5f512b/"},{"title":"刷题笔记 - 无重复字符的最长子串","text":"题目给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 示例示例一输入: s = &quot;abcabcbb&quot; 输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例二输入: s = &quot;bbbbb&quot; 输出: 1 解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例三输入: s = &quot;pwwkew&quot; 输出: 3 解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 示例四输入: s = &quot;&quot; 输出: 0 提示： 0 &lt;= s.length &lt;= 5 * 104 s 由英文字母、数字、符号和空格组成 题目来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters 个人思路用一个变量记录“无重复字符的最长子串”的长度，再用两个变量作为子串的起始和末尾的位置。整个字符串逐个检查，若当前字符在子字符串中没有出现，则子串起始位置不变，末尾位置+1（末尾位置移到当前字符位置）；若当前字符在子串中出现，则与当前子串长度是否大于记录的“无重复字符的最长子串”的长度进行比较，判断是否要更新，再将子串起始位置更新至子串中当前字符重复字符的下一位，末尾位置+1（与另种情况一样）。 整个字符串遍历完成后，比较当前子串长度与记录的“无重复字符的最长子串”的长度，检查是否需要更新。最后返回最终的结果。 代码C++代码：123456789101112131415161718192021222324252627282930313233343536class Solution {public: int lengthOfLongestSubstring(string s) { // 判断是否为控制符串，若是直接返回0。 if(s.length() == 0) { return 0; } int start{0}; int end{0}; int maxLen{0}; for(int i = 0; i &lt; s.length(); i++) { end = i; // 由于其实是从0开始，左右这里的长度并不包含当前字符。 int len = end - start; string subString = s.substr(start, len); // 若当前字符已经在子串中出现过。 if(subString.find(s[i]) != string::npos) { if(maxLen &lt; len) { maxLen = len; } // 起始位置移至重复字符的下一位。 start = start + subString.find(s[i]) + 1; } } // 判断当前子串长度是否大于记录的最大长度，防止子串一直到结束都没有重复从而没有更新最大长度。 return maxLen &gt; (end - start +1) ? maxLen : (end - start +1); }}; 注意事项std::string 中size() 和 length() 没有区别，都是返回字节数。 string::npos 表示 string 的结束位置，find() 找不到指定值的时候会返回string::npos，所以可以用来判断是否找到所需的值。","link":"/2021-aa7d6baca413/"},{"title":"刷题笔记 - 最长公共前缀","text":"题目编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例示例 1：输入：strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;] 输出：&quot;fl&quot; 示例 2：输入：strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;] 输出：&quot;&quot; 解释：输入不存在公共前缀。 提示： 1 &lt;= strs.length &lt;= 200 0 &lt;= strs[i].length &lt;= 200 strs[i] 仅由小写英文字母组成 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-common-prefix 个人思路 若传入数组长度为0或者仅有1个字符串，则直接返回 “” 或者该字符串； 之后便是将第一个字符串上的字符逐个设为待比较字符，遍历每个字符串逐个进行比较： 若比较过程中发现有空字符串则直接返回 “” ； 若发现当前比较的字符串中索引值超过某个字符串长度，则返回当前已确定的最长公共前缀。 发现有不同的字符也可以直接终止比较并返回当前已确定的最长公共前缀。 该方法说白了就是每个字符串逐个字符同时比较；所以另一种方法则是通过两个两个字符串逐个比较最长公共前缀，这里就不再赘述。 该方法时间复杂度为 O(mn)，m和n分别为传入数组的字符串个数和字符串的平均长度；空间复杂度为O(1)。 官方给出了另外两种方法，一个是分治一个是二分查找，但是这两种方法时间复杂度或空间复杂度并没有优势，且想法没有之前的方法直接，就不去过多关注了。但是自己写的代码还是可以参考改进的。 代码C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution {public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) { int num = strs.size(); if(num &lt;= 1) { // 若数组为0，返回&quot;&quot;；若为1，返回第一个字符串。 return num == 0 ? &quot;&quot;: strs[0]; } // 记录最长公共前缀 string lcStr{&quot;&quot;}; // 临时比较的字符 char temp{}; bool isEnd{false}; // 只用取第一个字符串的长度为最长循环次数即可 int length = strs[0].size(); for(int j = 0; j &lt; length; j++) { for(int i = 0; i &lt; num; i++) { if(strs[i] == &quot;&quot;) { return &quot;&quot;; } // 若是第一个字符串，则将该字符串相应位置的字符记为被判断字符，否则比较当前字符和被判断字符 if(i == 0) { temp = strs[i][j]; } else { // 若发现判断字符和当前字符不相等，直接结束循环返回当前已确定的前缀。 if(temp != strs[i][j]) { return lcStr; } // 若当前为数组的最后一个字符串且相等，则将被判断字符加入最长公共前缀中。 else if( i == num -1) { lcStr += temp; } } } } return lcStr; }}; C++（官方题解）12345678910111213141516171819class Solution {public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) { if (!strs.size()) { return &quot;&quot;; } int length = strs[0].size(); int count = strs.size(); for (int i = 0; i &lt; length; ++i) { char c = strs[0][i]; for (int j = 1; j &lt; count; ++j) { if (i == strs[j].size() || strs[j][i] != c) { return strs[0].substr(0, i); } } } return strs[0]; }};","link":"/2021-cd5b0f8c43a7/"},{"title":"刷题笔记 - 罗马数字转整数","text":"题目罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。 示例示例一输入: s = &quot;III&quot; 输出: 3 示例二输入: s = &quot;IV&quot; 输出: 4 示例三输入: s = &quot;IX&quot; 输出: 9 示例四输入: s = &quot;LVIII&quot; 输出: 58 解释: L = 50, V= 5, III = 3. 示例五输入: s = &quot;MCMXCIV&quot; 输出: 1994 解释: M = 1000, CM = 900, XC = 90, IV = 4. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/roman-to-integer 个人思路从罗马数字字符串末尾开始向前判断，若为‘I，X，C’时则判断其右边位数的值，来进行累加或者累减。但是这个思路有点暴力破解，等于将每个条件都进行判断。而实际只需用按顺序判断前一个字符所代表的数字是否小于后一个字符即可，若小于则累减，否则累加。 代码C++代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution { public: int romanToInt(string s) { // 累加数字 int total{0}; for(int i=s.length()-1 ; i &gt;= 0; i--) { int isMinus{ 1 }; switch(s[i]) { case 'I': if(s[i+1] == 'V' || s[i+1] == 'X') { isMinus = -1; } total += isMinus * 1; break; case 'V': total += 5; break; case 'X': if(s[i+1] == 'L' || s[i+1] == 'C') { isMinus = -1; } total += isMinus * 10; break; case 'L': total += 50; break; case 'C': if(s[i+1] == 'D' || s[i+1] == 'M') { isMinus = -1; } total += isMinus * 100; break; case 'D': total += 500; break; case 'M': total += 1000; break; } } return total; } }; 官方题解C++代码123456789101112131415161718192021222324252627class Solution {private: unordered_map&lt;char, int&gt; symbolValues = { {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000}, };public: int romanToInt(string s) { int ans = 0; int n = s.length(); for (int i = 0; i &lt; n; ++i) { int value = symbolValues[s[i]]; if (i &lt; n - 1 &amp;&amp; value &lt; symbolValues[s[i + 1]]) { ans -= value; } else { ans += value; } } return ans; }};","link":"/2021-4dd8d59c8b20/"},{"title":"刷题笔记 - 有效的括号","text":"题目给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 示例示例 1：输入：s = &quot;()&quot; 输出：true 示例 2：输入：s = &quot;()[]{}&quot; 输出：true 示例 3：输入：s = &quot;(]&quot; 输出：false 示例 4：输入：s = &quot;([)]&quot; 输出：false 示例 5：输入：s = &quot;{[]}&quot; 输出：true 提示： 1 &lt;= s.length &lt;= 104 s 仅由括号 ‘()[]{}’ 组成 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/valid-parentheses 个人思路看到题目之后很直接就联想到了使用栈来解决，因为每队括号必须闭合且按顺序，所以栈的后进先出很容易就可以比较右括号与最近的左括号是否匹配。 而因为括号成对出现，所以可以优先判断下字符串长度，如果为奇数则可以直接返回False。（题目已给出条件字符串不会为空） 在遍历字符串的时候，左括号可以依次 push 进栈中；遇到右括号时，则可以比较栈里最顶部的左括号是否匹配。 遍历结束后若栈为空，则说明所有括号都匹配，字符串有效。 该方法时间复杂度为 O(n)，空间复杂度为 O(n)。 代码C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution {public: bool isValid(string s) { // 若长度为奇数直接返回false; if((s.length())%2 != 0) { return false; } stack&lt;char&gt; a; for(int i = 0; i &lt; s.length(); i++) { char temp = s[i]; switch(temp) { case '(': a.push('('); break; case ')': if(a.empty() || a.top() != '(') { return false; } else { a.pop(); } break; case '[': a.push('['); break; case ']': if(a.empty() || a.top() != '[') { return false; } else { a.pop(); } break; case '{': a.push('{'); break; case '}': if(a.empty() || a.top() != '{') { return false; } else { a.pop(); } break; } } return a.empty(); }};","link":"/2021-a5555f2e2be4/"},{"title":"刷题笔记 - 合并两个有序链表","text":"题目将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例示例 1：输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4] 示例 2：输入：l1 = [], l2 = [] 输出：[] 示例 3：输入：l1 = [], l2 = [0] 输出：[0] 提示： 两个链表的节点数目范围是 [0, 50] -100 &lt;= Node.val &lt;= 100 l1 和 l2 均按 非递减顺序 排列 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/merge-two-sorted-lists 个人思路简单暴力的方法，就是新建一个节点，然后逐一比较两个节点的大小，加到新建的这个节点后面。l1或l2也逐一后移，直到其中一个链表全部添加完（成空链），则退出循环并将另一个非空链表加到新建链表之后。该方法时间复杂度为O(n+m)，n，m为两个链表的长度；空间复杂度为O(1)。 代码C++123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { // 本来做了l1和l2的空链表判断，但是后面循环里面有了这个功能并处理了剩余链表，所以这里不需用再单独判断了。 // if(l1 == nullptr || l2 == nullptr) // { // return l1 == nullptr ? l2 : l1; // } // temp作为移动的节点将相应节点加到combine后面。 ListNode combine{}; ListNode *temp{ &amp;combine }; // 若两个链表都不为空，则比较两链表节点的大小，并加到combine后面。 while(l1 != nullptr &amp;&amp; l2 != nullptr) { if(l1-&gt;val &lt; l2-&gt;val) { temp-&gt;next = l1; l1 = l1-&gt;next; }else{ temp-&gt;next = l2; l2 = l2-&gt;next; } temp = temp-&gt;next; } // 剩下的链可以直接加到合成链的后面。 temp-&gt;next = l1==nullptr?l2:l1; return combine.next; }};","link":"/2021-11ff5ab6d926/"},{"title":"刷题笔记 - 删除有序数组中的重复项","text":"题目给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 示例示例 1：输入：nums = [1,1,2] 输出：2, nums = [1,2] 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。 示例 2：输入：nums = [0,0,1,1,1,2,2,3,3,4] 输出：5, nums = [0,1,2,3,4] 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 提示： 0 &lt;= nums.length &lt;= 3 * 104 -104 &lt;= nums[i] &lt;= 104 nums 已按升序排列 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array 个人思路一开始的时候没有太读懂题目。其实题目意思就是将数组不重复的元素有序放在前面，并返回个数。接着答案会根据返回的个数输出数组的前n项。这也就是为什么我们返回的是数目，当答案输出的确是数组。 我们可以用两个指针来对数组进行修改：一个快指针进行数组遍历；另一个慢指针进行数组修改。快慢指针从第二个元素开始，快指针开始遍历数组。若快指针与前一个元素不同，则更新慢指针上的元素为快指针的元素，然后慢指针向后移动；若快指针与前一个元素相同，则继续遍历，慢指针不动。遍历完数组之后，快指针位于修改完的数组元素的下一位，而由于数组是从0开始作为索引。所以此时慢指针的数字也是数组无重复元素的个数（长度）。 Ps：更新的时候可以加一条判断，若快指针和慢指针不相等时候才更新慢指针元素。因为如果快慢指针相等，没必要进行元素更新；只有快慢指针不相等的时候，证明快慢指针中间出现重复元素，此时才需要更新慢指针元素。 该方法时间复杂度为 O(n)，空间复杂度为 O(1)。 代码C++12345678910111213141516171819202122232425262728class Solution {public: int removeDuplicates(vector&lt;int&gt;&amp; nums) { // 若数组长度为0，则直接返回 if(nums.size() == 0) { return 0; } int fast{1}; int slow{1}; for(slow = 1; slow &lt; nums.size(); slow++) { if(nums[slow] != nums[slow-1]) { // 若快慢指针处于同一位置，则不用复制，只有不处于同一位置时，才说明中间存在重复数组，需要更新。 if(fast != slow) { nums[fast] = nums[slow]; } fast++; } } return fast; }};","link":"/2021-b6458af3f313/"},{"title":"刷题笔记 - 移除元素","text":"题目给你一个数组nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例示例 1：输入：nums = [3,2,2,3], val = 3 输出：2, nums = [2,2] 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 示例 2：输入：nums = [0,1,2,2,3,0,4,2], val = 2 输出：5, nums = [0,1,4,0,3] 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 提示： 0 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 50 0 &lt;= val &lt;= 100 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-element 个人思路跟昨天做的题目《删除有序数组中的重复项》的思路类似，这道题也使用双指针：一个指针在数组开头(start)，另个指针在数组末尾(end)。当 start 指针在 end 指针左边时，start 指针逐步右移，当 start 指针的元素与 val 的值相等时，与 end 指针元素互换，并让 end 指针左移一位；循环直到两个指针相遇( start - end &lt; 0)。 该方法时间复杂度为 O(n)，空间复杂度为 O(1)。 代码C++123456789101112131415161718192021222324252627class Solution {public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int len = nums.size(); if(len == 0) { return 0; } int start {0}; int end {len-1}; while(start - end &lt; 1) { if(nums[start] == val) { nums[start] = nums[end]; end--; }else { start++; } } return start; }};","link":"/2021-72f516a7ba25/"},{"title":"刷题笔记 - 实现 strStr()","text":"题目实现 strStr() 函数。 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。 说明：当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。 示例示例 1：输入：haystack = &quot;hello&quot;, needle = &quot;ll&quot; 输出：2 示例 2：输入：haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot; 输出：-1 示例 3：输入：haystack = &quot;&quot;, needle = &quot;&quot; 输出：0 提示： 0 &lt;= haystack.length, needle.length &lt;= 5 * 104 haystack 和 needle 仅由小写英文字符组成 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/implement-strstr 个人思路暴力解法最直接想到的是暴力解法，这种解法思路简单但是耗时较长。 首先判断 needle 为0 和 haystack 为0这两种特殊情况。接着遍历haystack字符串，与needle字符串首字符进行比较，若相等，则继续匹配下一个字符。当出现不相等的时候跳出比较循环继续遍历haystack字符串。若haystack字符串遍历结束后依然没有匹配，则返回 -1。 该方法的时间复杂度为 O(mn)，空间复杂度为 O(1)。 代码C++（暴力解法）123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: int strStr(string haystack, string needle) { if(needle.length() == 0) { return 0; } if(haystack.length() == 0) { return -1; } bool isEnd{true}; for(int i = 0; i &lt; haystack.length(); i++) { // 若首字符像同，则开始比较后续的字符 if(haystack[i] == needle[0]) { for(int j = 1; j &lt; needle.length(); j++) { // 若发现出现不一样的字符，则跳出循环，并取消结束标记。 if(haystack[i+j] != needle[j]) { isEnd = false; break; } isEnd = true; } // 若结束，跳出循环，返回 if(isEnd) { return i; } } } return -1; }};","link":"/2021-81f924ed69a4/"},{"title":"刷题笔记 - 二分查找","text":"题目给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例示例 1:​ 输入: nums = [-1,0,3,5,9,12], target = 9​ 输出: 4​ 解释: 9 出现在 nums 中并且下标为 4 示例 2:​ 输入: nums = [-1,0,3,5,9,12], target = 2​ 输出: -1​ 解释: 2 不存在 nums 中因此返回 -1 提示： 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/binary-search 个人思路这道题其实就是“搜索插入位置”题目的基础班，就基本的二分查找。其方法思路我在之前的《刷题笔记 - 搜索插入位置》已经解释的非常详细了，唯一的区别就是该题因为只是查找，不用返回插入的坐标，在结束循环之前没有返回的话证明数组内没有目标值，最后的返回值为-1即可。 代码C++123456789101112131415161718192021222324252627class Solution {public: int search(vector&lt;int&gt;&amp; nums, int target) { int left{0}; int right = nums.size() - 1; while (right &gt;= left) { int mid = (right + left) / 2; int midVal = nums[mid]; // 如果中点与目标值相等，直接返回索引 if (target == midVal) { return mid; } if (target &gt; midVal) { left = mid + 1; } else if (target &lt; midVal) { right = mid - 1; } } // 循环结束仍未有返回值证明数组中不含目标值 return -1; }};","link":"/2021-1c6946f785d6/"},{"title":"刷题笔记 - 长度最小的子数组","text":"题目给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [$nums_l$, $nums_{l+1}$, …, $nums_{r-1}$, $nums_r$] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 示例示例 1：输入：target = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 示例 2：输入：target = 4, nums = [1,4,4] 输出：1 示例 3：输入：target = 11, nums = [1,1,1,1,1,1,1,1] 输出：0 提示： 1 &lt;= target &lt;= 109 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 105 进阶：如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimum-size-subarray-sum 个人思路我们可以利用类似双指针的思想，通过start和end两个指针建立一个滑动窗口。 start和end初始位置均在数组开头，首先移动end指针，开始构建窗口。当滑动窗口里面的子数组和大于等于target的时候，我们比较当前最小长度值来判断是否需要更新最小长度；之后end指针不动，移动start指针位置，并判断是否需要更新子数组最小长度，直到窗口内子数组和小于目标值，再继续先后移动end指针。直到整个数组遍历完毕。下面用表格来进行详细步骤演示，将会更加直观。 2 3 1 2 4 3 sum target length start, end 2 7 0 2 3 1 2 4 3 sum target length start end 5 7 0 2 3 1 2 4 3 sum target length start end 6 7 0 2 3 1 2 4 3 sum target length start end 8 7 4 2 3 1 2 4 3 sum target length start end 6 7 4 2 3 1 2 4 3 sum target length start end 10 7 4 2 3 1 2 4 3 sum target length start end 7 7 3 2 3 1 2 4 3 sum target length start end 6 7 3 2 3 1 2 4 3 sum target length start end 9 7 3 2 3 1 2 4 3 sum target length start end 7 7 2 该方法因为只用遍历一遍数组，所以时间复杂度为 O(n)，空间复杂度为 O(1)。 代码C++12345678910111213141516171819202122232425262728293031class Solution {public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) { // 活动窗口首位初试位置 int start{0}; int end{0}; // 长度最小连续子数组长度 int len{0}; // 窗口长度内子数组和 int sum{0}; for(int end = 0; end &lt; nums.size(); end++) { sum += nums[end]; while (sum &gt;= target) { int tempLen = end - start + 1; // 若当前子数组长度小于已知子数组长度 if(len == 0 || tempLen &lt; len) { len = tempLen; } // 窗口起始位置右移 sum -= nums[start]; start++; } } return len; }};","link":"/2021-389bb543d17d/"},{"title":"刷题笔记 - 螺旋矩阵","text":"题目给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。 示例示例 1： 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,2,3,6,9,8,7,4,5] 示例 2： 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] 输出：[1,2,3,4,8,12,11,10,9,5,6,7] 提示： m == matrix.length n == matrix[i].length 1 &lt;= m, n &lt;= 10 -100 &lt;= matrix[i][j] &lt;= 100 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/spiral-matrix 个人思路本题其实可以等价于将矩阵一圈一圈从外到内去遍历元素。上方是行不变列从左到右；右侧是列不变行从上到下；下方是行不变列从右到左；左侧是列不变行从下到上。所以可以设置四个变量分别表示每一圈上下左右位置，将元素在这之间遍历并添加到返回数组里面即可。值得注意的一点是，由于最后一圈会形成一个点、一列或者一行，所以在每次循环四边的时候在下方和左侧需要加一个判断，检查是否上下和左右有重合，若有，则不需要重复遍历。 时间复杂度为 $O(mn)$，每个元素都便利了一遍；空间复杂度为 $O(mn)$，建立了一个长度为 mn 的数组。 代码C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution {public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int row = matrix.size(); int col = matrix[0].size(); // 上下左右的索引值 int top = 0; int bottom = row - 1; int left = 0; int right = col - 1; vector&lt;int&gt; result; while ( left &lt;= right &amp;&amp; top &lt;= bottom) { // 顶部从左到右 for (int i = left; i &lt;= right; i++) { result.push_back(matrix[top][i]); } // 右边从上到下 for (int i = top + 1; i &lt;= bottom; i++) { result.push_back(matrix[i][right]); } if (left &lt; right &amp;&amp; top &lt; bottom) { // 底部从右到左 for (int i = right - 1; i &gt;= left; i--) { result.push_back(matrix[bottom][i]); } // 左边从下到上 for (int i = bottom - 1; i &gt; top; i--) { result.push_back(matrix[i][left]); } } // 顶部下移一层 top++; // 右边左移一位 right--; // 底部上移一层 bottom--; // 左边右移一位 left++; } return result; }};","link":"/2021-0459ab2ad0bb/"},{"title":"刷题笔记 - 最大子数组和","text":"题目给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组 是数组中的一个连续部分。 示例示例 1：输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2：输入：nums = [1] 输出：1 示例 3：输入：nums = [5,4,-1,7,8] 输出：23 提示： 1 &lt;= nums.length &lt;= 105 -104 &lt;= nums[i] &lt;= 104 进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-subarray 个人思路如果数组长度为1，则直接返回该元素。 否则从第二个元素开始，若前一个元素大于0，则将当前元素与前一个元素相加，把值更新到当前元素。比较当前元素的值与最大值，若大于最大值，则更新最大值。直到数组遍历完比，返回最大值即可。 该方法时间复杂度为 O(n)，空间复杂度为 O(1)。 示例： Round 最大值 初始 -2 1 -3 4 -1 2 1 -5 4 -2 1 -2 1 -3 4 -1 2 1 -5 4 1 -2&lt;0 2 -2 1 -2 4 -1 2 1 -5 41 1 -3+1 3 -2 1 -2 4 -1 2 1 -5 1 4 -2&lt;0 4 -2 1 -2 4 3 2 1 -5 4 4 -1+4 5 -2 1 -2 4 3 5 1 -5 4 5 2+3 6 -2 1 -2 4 3 2 6 -5 4 6 1+5 7 -2 1 -2 4 3 2 6 1 4 6 -5+1 8 -2 1 -2 4 3 2 6 1 5 6 4+1 代码C++1234567891011121314151617181920212223242526272829class Solution {public: int maxSubArray(vector&lt;int&gt;&amp; nums) { // 若长度为1直接返回结果 if(nums.size() &lt; 2) { return nums[0]; } // 将结果预设为第一个元素的值 int result = nums[0]; for(int i = 1; i &lt; nums.size(); i++) { // 若前一个元素大于零，当前元素与前一个元素相加，更新到当前元素 if(nums[i - 1] &gt; 0) { nums[i] += nums[i - 1]; } // 更新完之后若当前元素大于result，则更新 result if(result &lt; nums[i]) { result = nums[i]; } } return result; }};","link":"/2021-f0ffa6620951/"},{"title":"刷题笔记 - 螺旋矩阵II","text":"题目给你一个正整数 n ，生成一个包含 1 到 $n_2$ 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 示例示例 1： 输入：n = 3 输出：[[1,2,3],[8,9,4],[7,6,5]] 示例 2：输入：n = 1 输出：[[1]] 提示： 1 &lt;= n &lt;= 20 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/spiral-matrix-ii 个人思路这道题其实思路与《螺旋矩阵》一样，给一个正整数 n ，实际上就等于是矩阵行列为 n ，之后便是类似于《螺旋矩阵》中的遍历操作，只不过将获取矩阵元素换成赋值给矩阵相应位置。具体过程可以参考之前的思路。 该方法时间复杂度为 $O(n^2)$，空间复杂度也为$O(n^2)$，创建了一个 $n * n$ 的矩阵。 代码C++12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution {public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) { vector&lt;vector&lt;int&gt;&gt; matrix(n, vector&lt;int&gt;(n)); int top = 0; int bottom = n - 1; int left = 0; int right = n - 1; int i = 1; while (top &lt;= bottom &amp;&amp; left &lt;= right) { // 上方从左到右 for (int j = left; j &lt;= right; j++) { matrix[top][j] = i++; } // 右侧从上到下 for (int j = top + 1; j &lt;= bottom; j++) { matrix[j][right] = i++; } if (top &lt; bottom &amp;&amp; left &lt; right) { // 下方从右到左 for (int j = right - 1;j &gt;= left; j--) { matrix[bottom][j] = i++; } // 左侧从下到上 for (int j = bottom - 1; j &gt; top; j--) { matrix[j][left] = i++; } } top++; bottom--; left++; right--; } return matrix; }};","link":"/2021-a03717f51003/"},{"title":"刷题笔记 - 移除链表元素","text":"题目给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。 示例示例 1： 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5] 示例 2：输入：head = [], val = 1 输出：[] 示例 3：输入：head = [7,7,7,7], val = 7 输出：[] 提示： 列表中的节点数目在范围 [0, 104] 内 1 &lt;= Node.val &lt;= 50 0 &lt;= val &lt;= 50 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-linked-list-elements 个人思路题目并不难，只要一遍遍历一边对比找到与目标值一样的节点将它删除即可。我们判断每个节点的下一个节点是否是目标值，如果是的话，就将当前节点指向下下个节点，并将当前节点的下一个节点释放，即可完成删除。因为每次都是判断下一个节点，所以我们需要给头节点增加一个 0 节点当作初始节点方便进行判断。返回的时候我们返回这个 0 节点的下一位即是头节点。 该方法时间复杂度为 $O(n)$，因为要遍历所有的元素；空间复杂度为 $O(1)$，只用到了常数的空间存储。 代码C++12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* removeElements(ListNode* head, int val) { // 在head前新建一个节点 ListNode *zero = new ListNode(0, head); ListNode *current = zero; // 若下一个节点的值为目标值，则跳过该节点连接下下个节点；否则移到下一个节点继续判断。 while (current-&gt;next != nullptr) { if (current-&gt;next-&gt;val == val) { // 设置一个指针指向将被删的节点 ListNode *temp = current-&gt;next; current-&gt;next = current-&gt;next-&gt;next; // 释放被删除节点内存 delete temp; }else { current = current-&gt;next; } } return zero-&gt;next; }};","link":"/2021-2e8c5214b017/"},{"title":"刷题笔记 - 搜索插入位置","text":"题目给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为 O(log n) 的算法。 示例示例 1:输入: nums = [1,3,5,6], target = 5 输出: 2 示例 2:输入: nums = [1,3,5,6], target = 2 输出: 1 示例 3:输入: nums = [1,3,5,6], target = 7 输出: 4 示例 4:输入: nums = [1,3,5,6], target = 0 输出: 0 示例 5:输入: nums = [1], target = 0 输出: 0 提示: 1 &lt;= nums.length &lt;= 104 -104 &lt;= nums[i] &lt;= 104 nums 为无重复元素的升序排列数组 -104 &lt;= target &lt;= 104 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/search-insert-position 个人思路要求使用时间复杂度为 O(log n) 的算法，又因为数组是有序数组，很自然而言的想到二分法的思路。通过比较目标值与中间位置的值的大小，不断缩小范围进行比较： 若target 大于 mid 的值，则 left 变为 mid + 1；反之若 target 小于 mid 的值，则 right 变为 mid - 1；若 target 等于 mid 的值，则可以直接返回 mid 的值。循环直到出现 right &lt; left 为止，证明 target 是在 right 和 left 之间，则返回 right + 1 （即 left）作为插入位置即可。 通过表格就可以很直观的描述过程。 情况一： Round Index 0 1 2 3 4 5 target value mid 和 target 比较 1 Value 2 4 6 8 10 12 5 - l m r - target &lt; m ( 5 &lt; 6) =&gt; r = m - 1 2 Value 2 4 6 8 10 12 5 - l, m r - target &gt; m ( 5 &gt; 2) =&gt; l = m + 1 3 Value 2 4 6 8 10 12 5 - l, r, m - target &gt; m ( 5 &gt; 4) =&gt; l = m + 1 4 Value 2 4 6 8 10 12 3 - r l - r &lt; l =&gt; return r + 1;( return l ) 情况二： Round Index 0 1 2 3 4 5 target value mid 和 target 比较 1 Value 2 4 6 8 10 12 11 - l m r - target &gt; m ( 11 &gt; 6) =&gt; l = m + 1 2 Value 2 4 6 8 10 12 11 - l m r - target &gt; m ( 11 &gt; 10) =&gt; l = m + 1 3 Value 2 4 6 8 10 12 11 - l, r, m - target &lt; m ( 11 &lt; 12 ) =&gt; r = m - 1 4 Value 2 4 6 8 10 12 11 - r l - r &lt; l =&gt; return r + 1;( return l ) 情况三： Round Index 0 1 2 3 4 5 target value mid 和 target 比较 1 Value 2 4 6 8 10 12 8 - l m r - target &gt; m ( 8 &gt; 6) =&gt; l = m + 1 2 Value 2 4 6 8 10 12 8 - l m r - target&lt; m ( 8 &lt; 10) =&gt; r = m - 1 3 Value 2 4 6 8 10 12 8 - l, r, m - target == m =&gt; return m; ( m 则为 target 搜索到的位置) 该方法时间复杂度为 O(log n)，空间复杂度为 O(1)。 代码C++12345678910111213141516171819202122232425262728class Solution {public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) { int left{ 0 }; int right = nums.size() - 1; while(right &gt;= left) { int mid = (left + right) / 2; int midVal = nums[mid]; if( midVal == target) { return mid; } if( target &gt; midVal) { left = mid + 1; } else if( target &lt; midVal) { right = mid - 1; } } return left; }};","link":"/2021-feaef45bedf4/"},{"title":"刷题笔记 - 反转链表","text":"题目给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 示例示例 1： 输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1] 示例 2： 输入：head = [1,2] 输出：[2,1] 示例 3：输入：head = [] 输出：[] 提示： 链表中节点的数目范围是 [0, 5000] -5000 &lt;= Node.val &lt;= 5000 进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-linked-list 个人思路迭代该方法是迭代的方式完成反转，首先新建一个空指针作为结尾。之后一边遍历链表元素，一边用该元素创建新的链表元素，并将next指针指向之前的元素。这样便可完成链表反转。 该方法时间复杂度为 $O(n)$，因为需要遍历整个链表；空间复杂度也为$O(n)$，因为一边遍历一边新建元素，并没改变原来head为首的这条链表，而是新建了 $n$个元素组成了新的链表，使这条新链表与原来的链表相反。 如果可以优化一下代码，不建立新的链表，而是直接通过中间变量调换改变原来的链表，则可将空间复杂度变成了$O(1)$。 递归改题目递归思路的关键点在要将下一个节点递归下去的同时，对节点进行逆转操作。 结束条件为： 1(head == nullptr || head-&gt;next == nullptr) 以此判断链表已到末尾或者本身是空链表，返回当前head即可得到原来链表的末节点（即所需链表的首节点）； 将下一节点进行传递是： 1ListNode *current = reverseList(head-&gt;next); 因为最终我们需要的是逆转后链表的首节点，所以这里的 current 其实一直存储的就是该值，我们便需要在这段代码和最终 return current 这段代码之间，完成当前 head 和 head-&gt;next 的逆转。 逆转的代码如下： 12head-&gt;next-&gt;next = head;head-&gt;next = nullptr; 在将自身节点的下一个节点指向自己后，断开自己指向下一个节点的链接。即将 head 和 head-&gt;next 两个节点由原来的单链表，构建成双链表，再断开原先的指向，重新变回单链表。 该方法时间复杂度为 $O(n)$；空间复杂度为 $O(n)$，因为递归深度为$n$。 代码C++ （迭代，新建链表）12345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* reverseList(ListNode* head) { ListNode *result = nullptr; ListNode* current = head; while (current != nullptr) { ListNode *temp = new ListNode(current-&gt;val, result); result = temp; current = current-&gt;next; } return result; }}; C++ （迭代，优化空间复杂度）12345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* reverseList(ListNode* head) { ListNode* result = nullptr; ListNode* current = head; while (current != nullptr) { ListNode* temp = current-&gt;next; current-&gt;next = result; result = current; current = temp; } return result; }}; C++ （递归）12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* reverseList(ListNode* head) { if ( head == nullptr || head-&gt;next == nullptr) { return head; } // current 实际上一直是原来链表的最后一位元素，但是不断将 head-&gt;next 传下去进行操作 ListNode *current = reverseList(head-&gt;next); // 让当前head的下个元素指向自己，并断开当前head指向下个元素的链接 head-&gt;next-&gt;next = head; head-&gt;next = nullptr; return current; }};","link":"/2021-102da1183e5d/"},{"title":"刷题笔记 - 删除链表的第N个结点","text":"题目给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 示例示例 1： 输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] 示例 2：输入：head = [1], n = 1 输出：[] 示例 3：输入：head = [1,2], n = 1 输出：[1] 提示： 链表中结点的数目为 sz 1 &lt;= sz &lt;= 30 0 &lt;= Node.val &lt;= 100 1 &lt;= n &lt;= sz 进阶：你能尝试使用一趟扫描实现吗？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list 个人思路最直接易懂的方式就是先遍历一遍确定链表长度（len），算出删除第几个结点，将该结点删除即可。 如果把 head 结点算成第0个结点，则待删除结点为 len - n 个；若 head结点算成第1个结点，则待删除结点为第 len - n + 1 个结点。 结点删除可以使用 node-&gt;next = node-&gt;next-&gt;next 来操作，然后将删除点内存释放即可。 该方法时间复杂度为$O(n)$，空间复杂度为$O(1)$。 进阶：用一趟扫描实现可以使用前后双指针的方式，来进行一趟扫描实现。前指针用来“探路”，后指针用来指向要删除的地方，倒数第n个结点，只要前后指针相隔n个位置，即可使得当前指针遍历完链表的时候，后指针的下一位既是要删除的结点。 以示例1为例，最终为如下状态： 1 2 3 4 5 后指针位置 待删除位置 前指针位置 该方法时间复杂度依然为$O(n)$，空间复杂度也是$O(1)$。 代码C++12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { // 记录链表长度 int len{0}; ListNode *temp = head; while(temp != nullptr) { len++; temp = temp-&gt;next; } // 计算出要删除的位置（链表第一位序数为0） int del = len - n; int i{-1}; // 建立一个前置结点 temp = new ListNode(0, head); ListNode *result = temp; while(i &lt; len) { // 若下一个为要删除的结点，则删除下一个结点并连接到下下个结点，并释放内存 if (i+1 == del) { ListNode *delPtr = temp-&gt;next; temp-&gt;next = temp-&gt;next-&gt;next; // 释放该点内存 delete delPtr; break; }else { temp = temp-&gt;next; i++; } } return result-&gt;next; }}; C++（进阶）12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { // 建立前置结点 ListNode *zero = new ListNode(0, head); // 初始化前后指针 ListNode *first = zero; ListNode *second = zero; while(first != nullptr) { first = first-&gt;next; if (n &gt;= 0) { n--; } else { second = second-&gt;next; } } ListNode *temp = second-&gt;next; // 删除 second-&gt;next 结点 second-&gt;next = second-&gt;next-&gt;next; // 释放 second-&gt;next 结点处内存 delete temp; return zero-&gt;next; }};","link":"/2021-e590b1b38112/"},{"title":"刷题笔记 - 加一","text":"题目给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例示例 1：输入：digits = [1,2,3] 输出：[1,2,4] 解释：输入数组表示数字 123。 示例 2：输入：digits = [4,3,2,1] 输出：[4,3,2,2] 解释：输入数组表示数字 4321。 示例 3：输入：digits = [0] 输出：[1] 提示： 1 &lt;= digits.length &lt;= 100 0 &lt;= digits[i] &lt;= 9 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/plus-one 个人思路先将数组最后一位数字加1，之后从后往前遍历数组。若非首位位置的数字大于等于10（等于10），则其前一位（index - 1）位置数字加1，自己则与10取余（或者减10）。若数组第一位为10，则自身变为0，并在数组开头添加一个1（ vector.insert(vector.begin(), 1)）。 该方法时间复杂度为$O(n)$，n 为数组长度；空间复杂度为$O(1)$，使用了常数空间。 代码C++1234567891011121314151617181920212223class Solution {public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) { int len = digits.size(); digits[len - 1] += 1; for(int i = len -1; i &gt; 0; i--) { // 若非第一位大于等于10，则向前进1，并取余 if(digits[i] &gt;= 10) { digits[i-1] += 1; digits[i] %= 10; } } // 遍历完后若第一位为10，则向前添加一位，并自身取余（即变为0） if(digits[0] &gt;= 10) { digits.insert(digits.begin(), 1); digits[1] %= 10; } return digits; }};","link":"/2022-680328a3e122/"},{"title":"刷题笔记 - 环形链表","text":"题目给你一个链表的头节点 head ，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 如果链表中存在环，则返回 true 。 否则，返回 false 。 示例示例 1： 输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0 输出：true 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1 输出：false 解释：链表中没有环。 提示： 链表中节点的数目范围是 [0, 104] -105 &lt;= Node.val &lt;= 105 pos 为 -1 或者链表中的一个 有效索引 。 进阶：你能用 $O(1)$（即，常量）内存解决此问题吗？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/linked-list-cycle 个人思路我们可以使用快慢双指针来完成算法，并同时可以满足进阶要求——$O(1)$空间复杂度。 快慢双指针的思路是让快指针每次前移两个结点，慢指针前移一个结点，若链表中出现环，则快指针可以“追”上慢指针，使两个指针相等。否则快指针必然会先遍历完链表，使得自身结点或下一个结点为空指针。建立前置零结点是为了防止一开始快慢指针就相等，同时也让快指针以head为起点，循环一开始可以先判断自身是否为空接点，这样就可以不用提前判断空链表的情况。 该方法时间复杂度为$O(n)$，n为链表长度；空间复杂度为$O(1)$。 代码C++123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: bool hasCycle(ListNode *head) { // 建立前置结点 ListNode *zero = new ListNode(0, head); // 将快指针和慢指针分别初始化在 head 结点和前置结点作为起点 ListNode *fast = zero-&gt;next; ListNode *slow = zero; // 如果快慢指针没有相遇，便进入循环 while(fast != slow) { // 如果快指针本身或下一个结点为空指针，证明链表结束没有环 if(fast == nullptr || fast-&gt;next == nullptr) { return false; }else { // 快指针向前移动两个结点慢指针移动一个结点 fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; } } return true; }};","link":"/2021-5832d3f93986/"},{"title":"刷题笔记 - 最后一个单词的长度","text":"题目给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中最后一个单词的长度。 单词 是指仅由字母组成、不包含任何空格字符的最大子字符串 示例示例 1：输入：s = &quot;Hello World&quot; 输出：5 示例 2：输入：s = &quot; fly me to the moon &quot; 输出：4 示例 3：输入：s = &quot;luffy is still joyboy&quot; 输出：6 提示： 1 &lt;= s.length &lt;= 104 s 仅有英文字母和空格 ‘ ‘ 组成 s 中至少存在一个单词 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/length-of-last-word 个人思路题目十分简单，我们可以获取字符串长度之后反向进行遍历。只需要解决遇到空格的问题即可。我是用一个布尔值去判断是否遇到了最后一个单词，遇到了最后一个单词前碰到空格直接跳过当前循环；遇到最后一个单词后再碰到空格则跳出循环，返回统计到的值。 当然也可以先使用while循环之类的方法先处理字符串末尾的空格，这样就可以不用在统计的时候判断当前空格是最后一个单词前还是后的问题，哪种选择就看个人喜好。 该方法时间复杂度为O(n)，n 为最后一个单词的长度；空间复杂度为O(1)，只用了常数空间。 代码C++1234567891011121314151617181920212223242526class Solution {public: int lengthOfLastWord(string s) { int len = s.length(); int count { 0 }; // 标记是否遇到了最后一个单词 bool metLastWord { false }; for(int i = len -1; i &gt;= 0; i--) { // 如果末尾有空格，在没遇到最后一个单词前跳过 if(s[i] == ' ' &amp;&amp; metLastWord != true) { continue; } // 遇到单词并且又遇到了空格，证明单词已经结束，直接跳出循环 if(s[i] == ' ' &amp;&amp; metLastWord == true) { break; } // 如果不是空格，则开始计数 if(s[i] != ' ' ) { count++; metLastWord = true; } } return count; }};","link":"/2022-147578f67db5/"},{"title":"刷题笔记 - 按键持续时间最长的键","text":"题目LeetCode 设计了一款新式键盘，正在测试其可用性。测试人员将会点击一系列键（总计 n 个），每次一个。 给你一个长度为 n 的字符串 keysPressed ，其中 keysPressed[i] 表示测试序列中第 i 个被按下的键。releaseTimes 是一个升序排列的列表，其中 releaseTimes[i] 表示松开第 i 个键的时间。字符串和数组的 下标都从 0 开始 。第 0 个键在时间为 0 时被按下，接下来每个键都 恰好 在前一个键松开时被按下。 测试人员想要找出按键 持续时间最长 的键。第i 次按键的持续时间为 releaseTimes[i] - releaseTimes[i - 1]，第 0 次按键的持续时间为 releaseTimes[0] 。 注意，测试期间，同一个键可以在不同时刻被多次按下，而每次的持续时间都可能不同。 请返回按键 持续时间最长 的键，如果有多个这样的键，则返回 按字母顺序排列最大 的那个键。 示例示例 1：输入：releaseTimes = [9,29,49,50], keysPressed = &quot;cbcd&quot; 输出：&quot;c&quot; 解释：按键顺序和持续时间如下： 按下 'c' ，持续时间 9（时间 0 按下，时间 9 松开） 按下 'b' ，持续时间 29 - 9 = 20（松开上一个键的时间 9 按下，时间 29 松开） 按下 'c' ，持续时间 49 - 29 = 20（松开上一个键的时间 29 按下，时间 49 松开） 按下 'd' ，持续时间 50 - 49 = 1（松开上一个键的时间 49 按下，时间 50 松开） 按键持续时间最长的键是 'b' 和 'c'（第二次按下时），持续时间都是 20 'c' 按字母顺序排列比 'b' 大，所以答案是 'c' 示例 2：输入：releaseTimes = [12,23,36,46,62], keysPressed = &quot;spuda&quot; 输出：&quot;a&quot; 解释：按键顺序和持续时间如下： 按下 's' ，持续时间 12 按下 'p' ，持续时间 23 - 12 = 11 按下 'u' ，持续时间 36 - 23 = 13 按下 'd' ，持续时间 46 - 36 = 10 按下 'a' ，持续时间 62 - 46 = 16 按键持续时间最长的键是 'a' ，持续时间 16 提示： releaseTimes.length == n keysPressed.length == n 2 &lt;= n &lt;= 1000 1 &lt;= releaseTimes[i] &lt;= 109 releaseTimes[i] &lt; releaseTimes[i+1] keysPressed 仅由小写英文字母组成 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/slowest-key 个人思路这题的题目很长，一定要耐心读题。题目难度不难，一个字符串表示按下的按键，另个列表表示松开的时间，题目中也给出了提示，第i个按键的持续时间为releaseTimes[i] - releaseTimes[i - 1]。要得出最长时间的按键，我们只需要遍历完字符串和列表，获得最大值即可。 在遍历的过程中，如果发现更大的持续时间，则可以更新最大的按键；如果遍历时发现当前时间与已知的最大时间相等，则继续比较当前按键与已知最大按键的ascii值，即可比较出按字母顺序排列最大的按键。（直接通过运算符比较字符即使通过ascii来比较） 该方法时间复杂度为$O(n)$，n为字符串长度（或列表长度，一样的）；空间复杂度为$O(1)$，使用了常数个空间。 Ps:一开始题目没看清楚，理解错了题意，把题目理解成了要求每个按键的累计总持续时长最长的按键。那么这里就顺便也说一下如果是这样的要求的解题思路。 因为需要统计每个按键累计的持续时间。所以我们需要建立一个map来记录按键和对应的时间。在遍历的时候，获得当前按键和持续时间之后，在map中寻找是否已存在记录，如果没存在，则新建一个；若存在，则将当前持续时间加到统计的时间中。获取到累计的时间之后再与已知的最大持续时间比较，来判断是否需要更新结果。 这样时间复杂度仍然为$O(n)$，但是空间复杂度则变为$O(n)$，因为建立了一个按键长度的map。 代码C++（原题）123456789101112131415161718192021222324252627class Solution {public: char slowestKey(vector&lt;int&gt;&amp; releaseTimes, string keysPressed) { // 用来记录最长的时间，初始化为第一个按键时长 int maxTime { releaseTimes[0] }; // 记录结果，初始化为第一个按键 char result { keysPressed[0] }; int times = releaseTimes.size(); for(int i = 0; i &lt; times; i++) { // 当前按键的按压时间 int pressedT = i==0? releaseTimes[i] : releaseTimes[i] - releaseTimes[i-1]; char currentKey = keysPressed[i]; if (pressedT &gt; maxTime) { result = currentKey; maxTime = pressedT; }else if(pressedT == maxTime) { if(currentKey &gt; result) { result = currentKey; } } } return result; }}; C++ （若题目改为累计持续时间最长）1234567891011121314151617181920212223242526272829303132333435363738class Solution {public: char slowestKey(vector&lt;int&gt;&amp; releaseTimes, string keysPressed) { // 用来记录最长的时间 int maxTime { 0 }; // 记录结果 char result; map&lt;char, int&gt; pressedTime; int times = releaseTimes.size(); for(int i = 0; i &lt; times; i++) { // 当前按键的按压时间 int pressedT = i==0? releaseTimes[i] : releaseTimes[i] - releaseTimes[i-1]; char currentKey = keysPressed[i]; //改题目后与原答案的区别 //--------------start-------------- // 如果找不到当前按键，则新建；找到，则累加已有时间并更新map if( pressedTime.find(currentKey) == pressedTime.end()) { pressedTime.insert(make_pair(currentKey, pressedT)); }else { pressedTime[currentKey] += pressedT; pressedT = pressedTime[currentKey]; } //--------------end-------------- if (pressedT &gt; maxTime) { result = currentKey; maxTime = pressedT; }else if(pressedT == maxTime) { if(currentKey &gt; result) { result = currentKey; } } } return result; }}; 注意事项map中使用find()去寻找key的时候，返回值不是key所对应的value，而是该数据所在的迭代器。所以如果map中不存在所查找的key，返回值会与 end() 相等。所以可以通过比较 find() 的返回值与 end()是否相等来判断该map中是否有查找的key值。","link":"/2022-b5f06120bfd8/"},{"title":"刷题笔记 - 二进制求和","text":"题目给你两个二进制字符串，返回它们的和（用二进制表示）。 输入为 非空 字符串且只包含数字1和0。 示例示例 1:输入: a = &quot;11&quot;, b = &quot;1&quot; 输出: &quot;100&quot; 示例 2:输入: a = &quot;1010&quot;, b = &quot;1011&quot; 输出: &quot;10101&quot; 提示： 每个字符串仅由字符 ‘0’ 或 ‘1’ 组成。 1 &lt;= a.length, b.length &lt;= 10^4 字符串如果不是 “0” ，就都不含前导零。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/add-binary 个人思路如果精度满足的话我们可以直接将字符串的二进制转换成十进制数字，先加完之后再转换回二进制。但若是遇到了较长的二进制字符串，则很有可能会出现精度问题。 所以我在这里使用了类似竖式运算的方法，直接二进制相加减的策略，同位置的数字相加，逢二进一。 要做竖式运算，就想要给较短的字符串串首进行补“0”操作。算出两个字符串的长度差，再给较短的一边开头补“0”。 之后将两个字符串从后往前（从右往左）一步步相加：首先将字符转换成整型，由于二进制只有“0”和“1”，我就直接通过判断字符的方式进行转换；这里要注意，并不仅仅要同位置的两个数相加，我们还要设置一个进位数参与相加，以确保进位正确；相加完后，若结果大于1，则说明需要进位，将进位数更新为1，再让结果与2取余，便可以得到当前位置的结果；重复这一过程知道遍历完字符串。 最后，遍历完字符串之后我们需要判断进位数是否仍为1，若是，则需要在结果字符串开头补“1”。 该方法时间复杂度为$O(n)$，n为两字符串的较大值；空间复杂度为$O(1)$，除去返回值的字符串，我们使用了常数个空间。 代码C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution {public: string addBinary(string a, string b) { int lenA = a.length(); int lenB = b.length(); string result { &quot;&quot; }; // 进位值 int carry { 0 }; // 为短的字符串前补0 // 求出长度差 int diff = lenA - lenB; if( diff != 0) { // a短 if( diff &lt; 0) { diff = -diff; for(int i = 0; i &lt; diff; i++) { a = &quot;0&quot; + a; } } // b短 else if ( diff &gt; 0) { for(int i = 0; i &lt; diff; i++) { b = &quot;0&quot; + b; } } } // 相加 for(int i = a.length() - 1;i &gt;= 0;i--) { int tempA = a[i] == '0' ? 0 : 1; int tempB = b[i] == '0' ? 0 : 1; int temp = tempA + tempB + carry; // 若结果大于1，则证明需要进位 carry = temp &gt; 1 ? 1 : 0; // 若需要进位，则需要对当前位数跟2取余 result = carry == 1 ? to_string(temp % 2) + result : to_string(temp) + result; } // 先加完若仍需要进位，则在字符串前补1 if(carry == 1) { result = &quot;1&quot; + result; } return result; }};","link":"/2022-895a03ab871b/"},{"title":"刷题笔记 - 递增的三元子序列","text":"题目给你一个整数数组nums ，判断这个数组中是否存在长度为 3 的递增子序列。 如果存在这样的三元组下标(i, j, k)且满足 i &lt; j &lt; k ，使得nums[i] &lt; nums[j] &lt; nums[k] ，返回 true ；否则，返回 false 。 示例示例 1：输入：nums = [1,2,3,4,5] 输出：true 解释：任何 i &lt; j &lt; k 的三元组都满足题意 示例 2：输入：nums = [5,4,3,2,1] 输出：false 解释：不存在满足题意的三元组 示例 3：输入：nums = [2,1,5,0,4,6] 输出：true 解释：三元组 (3, 4, 5) 满足题意，因为 nums[3] == 0 &lt; nums[4] == 4 &lt; nums[5] == 6 提示： $1 &lt;= nums.length &lt;= 5 * 105$ $-231 &lt;= nums[i] &lt;= 231 - 1$ 进阶：你能实现时间复杂度为 O(n) ，空间复杂度为 O(1) 的解决方案吗？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/increasing-triplet-subsequence 个人思路这道题我们可以使用贪心算法来实现进阶要求，并且算法思路很好理解。 我们首先需要初始化两个变量first和second来分别表示第一个和第二个数字。将first初始化为数组的第一个元素，将second初始化为无穷大。算法的思路就是在寻找第三个数的同时，不断的相对缩小第一个和第二个数字，使得第三个数字更容易满足条件。 我们从数组第二项开始遍历，若当前数字大于second，则说明找到了 first &lt; second &lt; temp，可以直接返回true；若当前数字大于 first 但小于second，则让second等于当前数字，使得second的值相对缩小（仍然满足first &lt; second）；若当前数字小于first，则让first等于当前数字，适当的缩小first的值（从而让second缩小的可能性提高，让整个递增数列满足更多的可能）。 若遍历结束后仍然没有满足的条件，则可以返回false，并结束算法。 该方法的时间复杂度为$O(n)$，n为数组长度；空间复杂度为O(1)，使用了常数个空间。 代码C++1234567891011121314151617181920212223class Solution {public: bool increasingTriplet(vector&lt;int&gt;&amp; nums) { int first { nums[0] }; int second { INT_MAX }; for(int i = 1; i &lt; nums.size(); i++) { int temp = nums[i]; if( temp &gt; second) { return true; } // 让第二个数相对变小，但大于第一个数 else if(temp &gt; first &amp;&amp; temp &lt; second) { second = temp; } // 让第一个数相对变小 else if(temp &lt; first) { first = temp; } } return false; }};","link":"/2022-2433e670fd25/"},{"title":"刷题笔记 - 计算力扣银行的钱","text":"题目Hercy 想要为购买第一辆车存钱。他 每天 都往力扣银行里存钱。 最开始，他在周一的时候存入 1 块钱。从周二到周日，他每天都比前一天多存入 1 块钱。在接下来每一个周一，他都会比 前一个周一 多存入 1 块钱。 给你 n ，请你返回在第 n 天结束的时候他在力扣银行总共存了多少块钱。 示例示例 1：输入：n = 4 输出：10 解释：第 4 天后，总额为 1 + 2 + 3 + 4 = 10 。 示例 2：输入：n = 10 输出：37 解释：第 10 天后，总额为 (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37 。注意到第二个星期一，Hercy 存入 2 块钱。 示例 3：输入：n = 20 输出：96 解释：第 20 天后，总额为 (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96 。 提示： 1 &lt;= n &lt;= 1000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/calculate-money-in-leetcode-bank 个人思路这一道题没有什么难点，也不用想得特别复杂，直接使用等差数列求和公式即可算出结果。 先求出完整交了多少周，可以直接使用n / 7求出；再通过n % 7取余求出最后一周交了几天。以周为单位的话，每周交的钱是等差数列，求和公式为： $$ S\\mathop{}\\nolimits_{n}=\\frac{n \\left( a\\mathop{}\\nolimits_{1}+a\\mathop{}\\nolimits_{n} \\right) }{2} = na\\mathop{}\\nolimits_{1}+\\frac{n \\left( n-1 \\right) }{2}d $$ 而一周里面七天交的钱一样可以使用等差数列直接求出；周一交的钱其实等于它的周数，第几周，周一就交多少。这样通过公式既能前几周总共交了多少钱，以及最后一周几天交的钱，两者相加即可得到总共交了多少钱。 该方法时间复杂度为$O(1)$，因为可以直接计算出来；空间复杂度也为$O(1)$，使用了常数个空间。 代码C++1234567891011121314151617class Solution {public: int totalMoney(int n) { // 最后一周交了几天 int days = n % 7; // 交了完整的周数 int weeks = n / 7; // 等差数列 (an + a1) * d / 2 int w1 = (1 + 7) * 7 / 2; int total { 0 }; // 等差数列 S = a1 * n + d * n(n-1)/2 total = w1 * weeks + 7 * weeks * ( weeks - 1 ) / 2; total += (weeks + 1) * days + 1 * days * ( days - 1 ) / 2; return total; }};","link":"/2022-b9405ae8f2ac/"},{"title":"刷题笔记 - 至少是其他数字两倍的最大数","text":"题目给你一个整数数组 nums ，其中总是存在 唯一的 一个最大整数 。 请你找出数组中的最大元素并检查它是否 至少是数组中每个其他数字的两倍 。如果是，则返回 最大元素的下标 ，否则返回 -1 。 示例示例 1：输入：nums = [3,6,1,0] 输出：1 解释：6 是最大的整数，对于数组中的其他整数，6 大于数组中其他元素的两倍。6 的下标是 1 ，所以返回 1 。 示例 2：输入：nums = [1,2,3,4] 输出：-1 解释：4 没有超过 3 的两倍大，所以返回 -1 。 示例 3：输入：nums = [1] 输出：0 解释：因为不存在其他数字，所以认为现有数字 1 至少是其他数字的两倍。 提示： $1 &lt;= nums.length &lt;= 50$ $0 &lt;= nums[i] &lt;= 100$ $nums 中的最大元素是唯一的$ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/largest-number-at-least-twice-of-others 个人思路本题目十分简单，我们只需要三个变量在一次遍历中去记录最大值、次大值以及最大值的下标即可。 由于$0 &lt;= nums[i] &lt;= 100$，我们可以给最大值初始化为$nums[0]$，次大值 $bigger$和最大值下标$index$都初始化为$0$。这样即使数组只有一个元素，也不用额外进行判断。 之后遍历数组，如果遇到的元素大于最大值，则最大值赋值给次大值，当前元素赋值给最大值，这样每次便在更新最大值的同时保留次大值；但是不仅如此，我们同时还需要考虑另一种“当前元素比最大值小，但大于当前次大值”这样的情况，比如数组类似为$[1,2,9,6]$这样的情况，遍历到第三个元素的时候，最大值和次大值会更新为$9$和$2$，到了下一轮最大值不会更新，但是我们应该将次大值更新为$6$。 这样遍历完一边数组之后，我们就能得到最大值、次大值以及最大值的下标。之后我们即可比较$次大值* 2$是否不大于最大值即可确定返回值。（Ps：注意这里不要用最大值除以次大值是否大于等于2来判断，因为如果数组只有一个元素，或者次大值为0的时候，就会出现问题） 该方法时间复杂度为$O(n)$，$n$为数组长度；空间复杂度为$O(1)$，使用了常数个空间。 代码C++1234567891011121314151617181920212223class Solution {public: int dominantIndex(vector&lt;int&gt;&amp; nums) { // 最大的数 int biggest{ nums[0] }; // 第二大的数 int bigger{ 0 }; // 最大数的元素下标 int index { 0 }; for(int i = 1; i &lt; nums.size(); i++) { if( nums[i] &gt; biggest) { bigger = biggest; biggest = nums[i]; index = i; } else if (nums[i] &gt; bigger) { bigger = nums[i]; } } return bigger * 2 &lt;= biggest ? index : -1; }};","link":"/2022-b3b5a417bb30/"},{"title":"刷题笔记 - 链表随机节点","text":"题目给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 被选中的概率一样 。 实现 Solution 类： Solution(ListNode head) 使用整数数组初始化对象。 int getRandom() 从链表中随机选择一个节点并返回该节点的值。链表中所有节点被选中的概率相等。 示例示例： 输入 [&quot;Solution&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;] [[[1, 2, 3]], [], [], [], [], []] 输出 [null, 1, 3, 2, 2, 3] 解释 Solution solution = new Solution([1, 2, 3]); solution.getRandom(); // 返回 1 solution.getRandom(); // 返回 3 solution.getRandom(); // 返回 2 solution.getRandom(); // 返回 2 solution.getRandom(); // 返回 3 // getRandom() 方法应随机返回 1、2、3中的一个，每个元素被返回的概率相等。 提示： 链表中的节点数在范围$ [1, 10^4]$ 内 $-10^4 &lt;= Node.val &lt;= 10^4$ 至多调用 getRandom 方法 $10^4$ 次 进阶： 如果链表非常大且长度未知，该怎么处理？ 你能否在不使用额外空间的情况下解决此问题？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/linked-list-random-node 个人思路我是在初始化的时候新建一个private数组把链表所有的元素记录进去，在获取随机元素的时候通过获取0 ~ array.size()范围的随机数作为索引，在返回数组相应元素即可。 该方法时间复杂度为$O(n)$，n为链表长度；空间复杂度为$O(n)$，因为需要建立长度为n的数组。 代码C++123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {private: vector&lt;int&gt; content;public: Solution(ListNode* head) { while(head != nullptr) { content.push_back(head-&gt;val); head = head-&gt;next; } } int getRandom() { int index = rand() % (content.size()); return content[index]; }};/** * Your Solution object will be instantiated and called as such: * Solution* obj = new Solution(head); * int param_1 = obj-&gt;getRandom(); */ 注意事项在获取随机数的时候，直接使用rand() % number，可以获得 0 ~ （number-1）范围的随机数（包括0和number-1）。所以如果要想获得1 ~ number范围的随机数，则可以使用rand() % number + 1，即可获得。","link":"/2022-82ee71e7145f/"},{"title":"刷题笔记 - 设计链表","text":"题目设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。 在链表类中实现这些功能： get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。 addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。 addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。 addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。 deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。 示例：MyLinkedList linkedList = new MyLinkedList(); linkedList.addAtHead(1); linkedList.addAtTail(3); linkedList.addAtIndex(1,2); //链表变为1-&gt; 2-&gt; 3 linkedList.get(1); //返回2 linkedList.deleteAtIndex(1); //现在链表是1-&gt; 3 linkedList.get(1); //返回3 提示： 所有val值都在 [1, 1000] 之内。 操作次数将在 [1, 1000] 之内。 请不要使用内置的 LinkedList 库。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/design-linked-list 个人思路首先需要设计好链表结点的结构，这个非常简单，单链表的话有一个val用来存放值，还有一个指向下一个结点的指针next，另外还需要建立两个构造函数来供新建结点的时候使用，一个是只传入val值并让结点默认指向空指针；另一个则是传入结点值和下一个结点。两个构造函数都十分方便。 根据个人习惯，在之前刷题时候操作量表的时候都会新建立个虚拟头结点，所以在 MyLinkedList这个类的构造函数里面我也默认设置了虚拟头结点，方便一些功能操作，虚拟头结点和链表的数量我将他们设置成私有变量。 接下来就是主要功能：读取、添加和删除。 读取：题目要求“通过index获得第index个结点”，但实际上看例子我们能发现其实我们还是按照首结点的索引为0这样来处理即可，即index是获取第index + 1个结点。清楚这一点，这个功能就十分简单。我们首先判锻传入的index值是否合法，如果大于 size - 1，直接按题目要求返回-1即可；否则若索引合法，我们便可通过循环递减的方式从虚拟头结点开始，当index递减到0的时候，下一个结点的值变为所需要的值。 添加：addAtHead() 和 addAtIndex(index, val) 这两个功能整体思路一致，都是添加链表结点。注意一点的是，添加结点的时候要先让新结点指向待添加位置的下一个结点，再让上一个结点指向新结点，如果反过来先将当前结点指向新结点，那下一个结点就丢了。 删除：删除结点核心就是在找到待删除结点前一个结点之后，新建个临时指针指向待删除的结点，再让待删除结点的前一个结点的next，指向next-&gt;next，最后再delete临时结点即可。 代码C++ （单链表）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394class MyLinkedList {public: // 链表结点结构 struct LinkedNode { int val; LinkedNode* next; LinkedNode(int val): val(val), next(nullptr) {}; LinkedNode(int val, LinkedNode* next): val(val), next(next) {}; }; // 初始化链表 MyLinkedList() { _dummyHead = new LinkedNode(0); _size = 0; } int get(int index) { // 索引无效返回 -1 if(index &gt; _size - 1) { return -1; }else { LinkedNode* temp = _dummyHead; while(index != 0) { temp = temp-&gt;next; index--; } return temp-&gt;next-&gt;val; } } void addAtHead(int val) { // 创建一个新结点并指向原来的头结点 LinkedNode* temp = new LinkedNode(val, _dummyHead-&gt;next); // 让虚拟头结点指向新建的结点 _dummyHead-&gt;next = temp; _size++; } void addAtTail(int val) { LinkedNode* temp = _dummyHead; // 让temp到结尾结点 while(temp-&gt;next != nullptr) { temp = temp-&gt;next; } temp-&gt;next = new LinkedNode(val); _size++; } void addAtIndex(int index, int val) { if(index &gt; _size){ return; } LinkedNode* temp = _dummyHead; while(index != 0) { temp = temp-&gt;next; index--; } // 当前temp在要插入结点的前一个位置 LinkedNode* added = new LinkedNode(val, temp-&gt;next); temp-&gt;next = added; _size++; } void deleteAtIndex(int index) { if(index &gt; _size - 1) { return; } LinkedNode* temp = _dummyHead; while(index != 0) { temp = temp-&gt;next; index--; } // 当前temp在要插入结点的前一个位置 LinkedNode* deleted = temp-&gt;next; temp-&gt;next = temp-&gt;next-&gt;next; delete deleted; _size--; }private: LinkedNode* _dummyHead; int _size;};/** * Your MyLinkedList object will be instantiated and called as such: * MyLinkedList* obj = new MyLinkedList(); * int param_1 = obj-&gt;get(index); * obj-&gt;addAtHead(val); * obj-&gt;addAtTail(val); * obj-&gt;addAtIndex(index,val); * obj-&gt;deleteAtIndex(index); */","link":"/2022-29b32ba9f4a4/"},{"title":"刷题笔记 - 力扣349、884、83、2000","text":"一、两个数组的交集题目给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。 示例示例 1：输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2] 示例 2：输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[9,4] 解释：[4,9] 也是可通过的 提示： 1 &lt;= nums1.length, nums2.length &lt;= 1000 0 &lt;= nums1[i], nums2[i] &lt;= 1000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/intersection-of-two-arrays 思路可以建立一个 map，通过哈希表的方式进行比对，分别遍历两个数组。在遍历第一个数组的时候，建立索引和对应的值，将值设为1，即便重复出现，依然设为1即可；遍历第二个数组的时候就可以对索引进行比对，如果存在并且为1，则说明在第一个数组中存在，即可筛选出来。 该方法时间复杂度为$O(n+m)$，$n, m$为两个数组的长度；空间复杂度为$O(n+m)$，空间取决于两个数组的长度。 代码C++1234567891011121314151617181920212223class Solution {public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { unordered_map&lt;int, int&gt; resultMap; vector&lt;int&gt; result; for(int i = 0; i &lt; nums1.size(); i++) { resultMap[nums1[i]] = 1; } for(int i = 0; i &lt; nums2.size(); i++) { if(resultMap.count(nums2[i]) != 0) { // 值为1说明没有统计过，否则证明是重复的数字 if(resultMap[nums2[i]] == 1){ result.push_back(nums2[i]); resultMap[nums2[i]]++; } } } return result; }}; 二、两句话中的不常见单词题目句子 是一串由空格分隔的单词。每个 单词 仅由小写字母组成。 如果某个单词在其中一个句子中恰好出现一次，在另一个句子中却 没有出现 ，那么这个单词就是 不常见的 。 给你两个 句子 s1 和 s2 ，返回所有 不常用单词 的列表。返回列表中单词可以按 任意顺序 组织。 示例示例 1：输入：s1 = &quot;this apple is sweet&quot;, s2 = &quot;this apple is sour&quot; 输出：[&quot;sweet&quot;,&quot;sour&quot;] 示例 2：输入：s1 = &quot;apple apple&quot;, s2 = &quot;banana&quot; 输出：[&quot;banana&quot;] 提示： 1 &lt;= s1.length, s2.length &lt;= 200 s1 和 s2 由小写英文字母和空格组成 s1 和 s2 都不含前导或尾随空格 s1 和 s2 中的所有单词间均由单个空格分隔 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/uncommon-words-from-two-sentences 思路这个题目可以理解成我们要获取两个句子中，总共只出现过一次的词语。那么我的思路是将两个字符串之间添加空格，合并成一个字符串，然后提取这个字符串中只出现过一次的词语。我们可以通过哈希表，在遍历字符串的同时进行统计，最后输出相应答案即可。 该方法时间复杂度和空间复杂度均为$O(n+m)$，跟两个字符串长度有关。 代码C++123456789101112131415161718192021222324252627282930313233class Solution {public: vector&lt;string&gt; uncommonFromSentences(string s1, string s2) { // 合并两个字符串 string total = s1 + &quot; &quot; + s2; string temp; // 建立一个map来统计次数 unordered_map&lt;string, int&gt; wordList; vector&lt;string&gt; result; for(int i = 0; i &lt; total.size(); i++) { if(total[i] != ' ') { temp += total[i]; } // 最后一个单词不要忘记统计 if(total[i] == ' ' || i == total.size()-1) { if(wordList.find(temp) != wordList.end()) { wordList[temp]++; }else{ wordList[temp] = 1; } temp = &quot;&quot;; } } for(const auto &amp; [key, value] : wordList) { if(value == 1) { result.push_back(key); } } return result; }}; 3: 三、删除排序链表中的重复元素题目给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。 示例示例 1： 输入：head = [1,1,2] 输出：[1,2] 示例 2： 输入：head = [1,1,2,3,3] 输出：[1,2,3] 提示： 链表中节点数目在范围 [0, 300] 内 -100 &lt;= Node.val &lt;= 100 题目数据保证链表已经按升序 排列 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list 思路该题目中有一个条件很重要，那就是该链表是已排序的链表。这意味着同样的元素都是放在一起的，不会出现穿插。那么我们就可以使用快慢双指针，十分简单的去判断。 首先，如果链表为空则直接返回即可，否则快慢指针都从首位开始； 快指针不断向后移动，如果当前快指针的元素与慢指针不相等，那么就让当前慢指针的下一个结点为当前快指针的节点，并让慢指针更新到快指针的位置，直到遍历完链表，否则慢指针不变，快指针继续向后移动； 如果快指针移动到了末尾且仍然与慢指针元素相等，则让慢指针的下一个节点指向空结点并结束循环。 该方法的时间复杂度为$O(n)$，n为链表长度；空间复杂度为$O(1)$，使用了常数个空间。 代码C++12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* deleteDuplicates(ListNode* head) { if(head == nullptr) return head; ListNode *slow = head; ListNode *fast = slow; while(slow-&gt;next != nullptr) { fast = fast-&gt;next; if(fast-&gt;val != slow-&gt;val) { slow-&gt;next = fast; slow = fast; } else if ( fast-&gt;val == slow-&gt;val &amp;&amp; fast-&gt;next == nullptr) { slow-&gt;next = nullptr; break; } else { continue; } } return head; }}; 四、反转单词前缀题目给你一个下标从 0 开始的字符串 word 和一个字符 ch 。找出 ch 第一次出现的下标 i ，反转 word 中从下标 0 开始、直到下标 i 结束（含下标 i ）的那段字符。如果 word 中不存在字符 ch ，则无需进行任何操作。 例如，如果 word = &quot;abcdefd&quot; 且 ch = &quot;d&quot; ，那么你应该 反转 从下标 0 开始、直到下标 3 结束（含下标 3 ）。结果字符串将会是 “ dcba efd” 。 返回 结果字符串 。 示例示例 1：输入：word = &quot;abcdefd&quot;, ch = &quot;d&quot; 输出：&quot;dcbaefd&quot; 解释：&quot;d&quot; 第一次出现在下标 3 。 反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 &quot;dcbaefd&quot; 。 示例 2：输入：word = &quot;xyxzxe&quot;, ch = &quot;z&quot; 输出：&quot;zxyxxe&quot; 解释：&quot;z&quot; 第一次也是唯一一次出现是在下标 3 。 反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 &quot;zxyxxe&quot; 。 示例 3：输入：word = &quot;abcd&quot;, ch = &quot;z&quot; 输出：&quot;abcd&quot; 解释：&quot;z&quot; 不存在于 word 中。 无需执行反转操作，结果字符串是 &quot;abcd&quot; 。 提示： 1 &lt;= word.length &lt;= 250 word 由小写英文字母组成 ch 是一个小写英文字母 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-prefix-of-word 思路方法一：使用栈基本思路就是遍历字符串，直到匹配到与ch相同的字符时跳出遍历。在遍历的同时将字符push到栈中。遍历结束后，将栈里面的元素逐个从word开头进行修改。最后返回 word 即可。 我在遍历的时候加了个 isIn 的布尔值进行记录，若是跳出结束的遍历，则证明字符串中有目标字符；否则证明遍历结束仍然不存在目标字符，这时候直接返回word即可。 该方法时间复杂度为$O(n)$，空间复杂度也为$O(n)$。 方法二：直接使用 STL库 函数这道题也可以直接使用 std::reverse() 来进行。 该方法时间复杂度为$O(n)$。 代码C++(方法一)1234567891011121314151617181920212223242526class Solution {public: string reversePrefix(string word, char ch) { stack&lt;char&gt; temp; // 记录word中是否含有 ch bool isIn{false}; for(int i = 0; i &lt; word.size(); i++) { if(word[i] != ch) { temp.push(word[i]); }else { temp.push(word[i]); isIn = true; break; } } int i = 0; while(!temp.empty() &amp;&amp; isIn == true) { word[i] = temp.top(); temp.pop(); i++; } return word; }}; C++(方法二)1234567891011class Solution {public: string reversePrefix(string word, char ch) { int index = word.find(ch); if(index != string::npos) { reverse(word.begin(), word.begin() + index + 1); } return word; }};","link":"/2022-45fe5716c69c/"},{"title":"刷题笔记 - 力扣1725，1748，2006，1984","text":"一、可以形成最大正方形的矩形数目题目给你一个数组 rectangles ，其中rectangles[i] = [li, wi]表示第i个矩形的长度为 li 、宽度为 wi 。 如果存在 k 同时满足 k &lt;= li 和 k &lt;= wi ，就可以将第i个矩形切成边长为 k 的正方形。例如，矩形 [4,6] 可以切成边长最大为 4 的正方形。 设 maxLen 为可以从矩形数组 rectangles 切分得到的 最大正方形 的边长。 请你统计有多少个矩形能够切出边长为 maxLen 的正方形，并返回矩形 **数目 **。 示例示例 1：输入：rectangles = [[5,8],[3,9],[5,12],[16,5]] 输出：3 解释：能从每个矩形中切出的最大正方形边长分别是 [5,3,5,5] 。 最大正方形的边长为 5 ，可以由 3 个矩形切分得到。 示例 2：输入：rectangles = [[2,3],[3,7],[4,3],[3,7]] 输出：3 提示： 1 &lt;= rectangles.length &lt;= 1000 rectangles[i].length == 2 1 &lt;= li, wi &lt;= 109 li != wi 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/number-of-rectangles-that-can-form-the-largest-square 思路题目看似有点绕，实际上可以理解为“找出每个数组中，最大较小值的个数”。我们只需要边遍历所有数组，边比较每个数组中较小的那个值是否大于或者等于当前记录的最大值：如果大于，则更新最大值并重新计数；若等于，则计数加一。最后返回计数即可。 该方法时间复杂度为$O(n)$，我们需要遍历整个数组；空间复杂度为$O(1)$，只是用了常数空间。 代码C++123456789101112131415161718class Solution {public: int countGoodRectangles(vector&lt;vector&lt;int&gt;&gt;&amp; rectangles) { int maxLen { 0 }; int maxK { 0 }; for(int i = 0; i &lt; rectangles.size(); i++) { int temp = min(rectangles[i][0], rectangles[i][1]); if(temp == maxK) { maxLen++; }else if (temp &gt; maxK) { maxK = temp; maxLen = 1; } } return maxLen; }}; 二、唯一元素的和题目给你一个整数数组 nums 。数组中唯一元素是那些只出现 恰好一次 的元素。 请你返回 nums 中唯一元素的 和 。 示例示例 1：输入：nums = [1,2,3,2] 输出：4 解释：唯一元素为 [1,3] ，和为 4 。 示例 2：输入：nums = [1,1,1,1,1] 输出：0 解释：没有唯一元素，和为 0 。 示例 3 ：输入：nums = [1,2,3,4,5] 输出：15 解释：唯一元素为 [1,2,3,4,5] ，和为 15 。 提示： 1 &lt;= nums.length &lt;= 100 1 &lt;= nums[i] &lt;= 100 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sum-of-unique-elements 思路我们可以通过建立一个哈希表，来对遇到的数字进行标记，实现一次遍历完成要求，具体方式如下： 遍历数组的时候查询哈希表中是否存在该数字，若不存在，则直接将当前数字与 result 相加，并在哈希表新建数字，对应的值为 -1； 若在哈希表中找到了数字，证明该数字不是唯一，需要减掉或者不加进来，那么我们可以通过哈希表中该数字对应的值来进行区分，将该值视为系数，想家的时候乘上系数即可。上一步骤中所说，初次遇到后将对应值设为**-1**，那么下次遇到的时候相乘完再相加即可实现减掉重复数值； 最后不管哈希表中原来数字对应的值是什么，只要在遍历过程中遇到了，先加完之后都将值改为0，以保证再遇到的时候相乘的系数是0，实现不加入结果的目的。 该方法时间复杂度为$O(n)$，空间复杂度也为$O(n)$。 代码C++123456789101112131415161718192021class Solution {public: int sumOfUnique(vector&lt;int&gt;&amp; nums) { unordered_map&lt;int, int&gt; check; int result { 0 }; for(int i = 0; i &lt; nums.size(); i++) { int current = nums[i]; // 若check里没有，则证明第一次遇到，result相加并添加 -1标记； if(check.find(current) == check.end()) { result += current; check[current] = -1; }else { // 若找到则直接与对应值相乘再与结果相加即可 result += current * check[current]; check[current] = 0; } } return result; }}; 三、差的绝对值为 K 的数对数目题目给你一个整数数组 nums 和一个整数 k ，请你返回数对 (i, j) 的数目，满足 i &lt; j 且 |nums[i] - nums[j]| == k 。 |x| 的值定义为： 如果 x &gt;= 0 ，那么值为 x 。如果 x &lt; 0 ，那么值为 -x 。 示例示例 1：输入：nums = [1,2,2,1], k = 1 输出：4 解释：差的绝对值为 1 的数对为： - [1,2,2,1] - [1,2,2,1] - [1,2,2,1] - [1,2,2,1] 示例 2：输入：nums = [1,3], k = 3 输出：0 解释：没有任何数对差的绝对值为 3 。 示例 3：输入：nums = [3,2,1,5,4], k = 2 输出：3 解释：差的绝对值为 2 的数对为： - [3,2,1,5,4] - [3,2,1,5,4] - [3,2,1,5,4] 提示： 1 &lt;= nums.length &lt;= 200 1 &lt;= nums[i] &lt;= 100 1 &lt;= k &lt;= 99 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/count-number-of-pairs-with-absolute-difference-k 思路我用的思路很简单直接，因为是要找满足条件的对子数量。那只要将数组中每个数字的个数统计出来存在哈希表中，再去读取每个数字满足条件的数字的个数，之后相乘再累加即可。如果数组中不存在满足的数字，则跳过即可。 该方法时间复杂度为$O(n)$，遍历了一边数组，并遍历了一边创建的哈希表，耗费$2n$时间；空间复杂度为$O(n)$，根据数组个数建立了一个哈希表。 代码C++12345678910111213141516171819202122232425262728class Solution {public: int countKDifference(vector&lt;int&gt;&amp; nums, int k) { int total { 0 }; // 记录nums中个数字的个数 unordered_map&lt;int, int&gt; numToCount; for(int i = 0; i &lt; nums.size(); i++) { int temp = nums[i]; if(numToCount.find(temp) != numToCount.end()) { numToCount[temp]++; }else { numToCount[temp] = 1; } } for(auto&amp; num : numToCount) { if(numToCount.find(num.first + k) == numToCount.end()){ continue; }else { total += num.second * numToCount[num.first + k]; } } return total; }}; 四、学生分数的最小差值题目给你一个 下标从 0 开始 的整数数组 nums ，其中 nums[i] 表示第 i 名学生的分数。另给你一个整数 k 。 从数组中选出任意 k 名学生的分数，使这 k 个分数间 最高分 和 最低分 的 差值 达到 **最小化 **。 返回可能的 最小差值 。 示例示例 1：输入：nums = [90], k = 1 输出：0 解释：选出 1 名学生的分数，仅有 1 种方法： - [90] 最高分和最低分之间的差值是 90 - 90 = 0 可能的最小差值是 0 示例 2：输入：nums = [9,4,1,7], k = 2 输出：2 解释：选出 2 名学生的分数，有 6 种方法： - [9,4,1,7] 最高分和最低分之间的差值是 9 - 4 = 5 - [9,4,1,7] 最高分和最低分之间的差值是 9 - 1 = 8 - [9,4,1,7] 最高分和最低分之间的差值是 9 - 7 = 2 - [9,4,1,7] 最高分和最低分之间的差值是 4 - 1 = 3 - [9,4,1,7] 最高分和最低分之间的差值是 7 - 4 = 3 - [9,4,1,7] 最高分和最低分之间的差值是 7 - 1 = 6 可能的最小差值是 2 提示： 1 &lt;= k &lt;= nums.length &lt;= 1000 0 &lt;= nums[i] &lt;= 105 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimum-difference-between-highest-and-lowest-of-k-scores 思路因为可以任意取k个数字，并要求最大最小差值最小，那么我们可以先进行排序，然后以k为一个滑动窗口，比较最大最小值的插值，取最小的即可。整体步骤分两步： 从小到大排序，直接使用C++的*sort()*排序即可； 接着使用滑动窗口，比较首位插值并返回最小值即可。 该方法时间复杂度为$O(nlogn)$，*sort()排序时间复杂度我$O(nlogn)$，滑动窗口则是$O(n)$；空间复杂度的话，查到的sort()*空间复杂度为$O(nlogn)$，因为用到了栈排序，所以整体空间复杂度为$O(nlogn)$。 代码C++1234567891011121314class Solution {public: int minimumDifference(vector&lt;int&gt;&amp; nums, int k) { int result { INT_MAX }; sort(nums.begin(), nums.end()); for(int i = 0; i + k &lt;= nums.size(); i++) { result = result &gt; nums[i+k-1] - nums[i] ? nums[i+k-1] - nums[i] : result; } return result; }};","link":"/2022-a85a69bb262d/"},{"title":"刷题笔记 - 力扣1189、717、917","text":"一、“气球” 的最大数量题目给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词** “balloon”（气球）**。 字符串 text 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 **”balloon”**。 示例示例 1： 输入：text = &quot;nlaebolko&quot; 输出：1 示例 2： 输入：text = &quot;loonbalxballpoon&quot; 输出：2 示例 3：输入：text = &quot;leetcode&quot; 输出：0 提示： 1 &lt;= text.length &lt;= 10^4 text 全部由小写英文字母组成 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-number-of-balloons 思路思路其实很简单，我们只要统计出balloon每个字母的个数，再找出最小的值既是能拼出balloon的个数。这里面需要注意的一点是 l 和 o 因为需要两个，所以它们的个数需要除以2。 时间复杂度为$O(n+C)$，我们需要遍历字符串一遍，以及找出最小的个数。$C$ 为 $5$；空间复杂度为$O(C)$，我们需要存储字符来进行数量统计，这里 $C$ 也为 $5$。 代码C++123456789101112131415161718192021class Solution {public: int maxNumberOfBalloons(string text) { unordered_map&lt;char, int&gt; balloon { {'b', 0}, {'a', 0}, {'l', 0}, {'o', 0}, {'n', 0} }; for(int i = 0; i &lt; text.length(); i++) { char temp = text[i]; if(temp != 'b' &amp;&amp; temp != 'a' &amp;&amp; temp != 'l' &amp;&amp; temp != 'o' &amp;&amp; temp != 'n') { continue; } balloon[temp]++; } return min({balloon['b'], balloon['a'], balloon['l']/2, balloon['o']/2, balloon['n']}); }}; 二、1比特与2比特字符题目有两种特殊字符： 第一种字符可以用一个比特 0 来表示 第二种字符可以用两个比特(10 或 11)来表示 给定一个以 0 结尾的二进制数组 bits ，如果最后一个字符必须是一位字符，则返回 true 。 示例示例 1:输入: bits = [1, 0, 0] 输出: true 解释: 唯一的编码方式是一个两比特字符和一个一比特字符。 所以最后一个字符是一比特字符。 示例 2:输入: bits = [1, 1, 1, 0] 输出: false 解释: 唯一的编码方式是两比特字符和两比特字符。 所以最后一个字符不是一比特字符。 提示: 1 &lt;= bits.length &lt;= 1000 bits[i] == 0 or 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/1-bit-and-2-bit-characters 思路通过题目我们可以知道如果以1开头，则肯定占用两个字符，所以我们直接从头遍历数组，只要遇到1，我们就检查该位置后的第二位是否超出了数组范围，如果超出，则证明开数组是以两个字符结尾，返回false；否则将指针跳两个位继续遍历。 该方法时间复杂度为$O(n)$，我们需要遍历一边数组；空间复杂度为$O(1)$。 代码123456789101112131415class Solution {public: bool isOneBitCharacter(vector&lt;int&gt;&amp; bits) { for(int i = 0; i &lt; bits.size(); i++) { if(bits[i] == 1) { if(i+2 &gt;= bits.size()) { return false; } else { i++; } } } return true; }}; 三、仅仅反转字母题目给你一个字符串 s ，根据下述规则反转字符串： 所有非英文字母保留在原有位置。 所有英文字母（小写或大写）位置反转。 返回反转后的 s 。 示例示例 1：输入：s = &quot;ab-cd&quot; 输出：&quot;dc-ba&quot; 示例 2：输入：s = &quot;a-bC-dEf-ghIj&quot; 输出：&quot;j-Ih-gfE-dCba&quot; 示例 3：输入：s = &quot;Test1ng-Leet=code-Q!&quot; 输出：&quot;Qedo1ct-eeLg=ntse-T!&quot; 提示 1 &lt;= s.length &lt;= 100 s 仅由 ASCII 值在范围 [33, 122] 的字符组成 s 不含 '\\&quot;' 或 '\\\\' 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-only-letters 思路这道题目非常简单，我们只需要使用头尾两个指针，进行遍历字符串即可： 若指针指的位置均为字母，则对调两字母； 若头指针不是字母，则右移一位；若尾指针不是字母，则左移一位； 当头指针不小于尾指针的时候，结束遍历； 这样我们即可得到“仅反转字母”的字符串。 该方法时间复杂度为$O(n)$，我们需要遍历字符串；空间复杂度为$O(1)$，使用常数个空间。 代码C++1234567891011121314151617181920212223class Solution {public: string reverseOnlyLetters(string s) { int head { 0 }; int tail = s.length() - 1; while(head &lt; tail) { if(isalpha(s[head]) &amp;&amp; isalpha(s[tail])) { swap(s[head], s[tail]); head++; tail--; }else { if(!isalpha(s[head])) { head++; } if(!isalpha(s[tail])) { tail--; } } } return s; }};","link":"/2022-c4b520122101/"},{"title":"《GAMES101：现代游戏引擎：从入门到实践》课程笔记整理（持续更新。。。）","text":"课程信息链接https://games-cn.org/games104/ https://games104.boomingtech.com/sc/ 参考资料“Game Engine Architecture”, 3rd or later editions. 知识点整理Basic Elements 基本要素 Engine Structure and Layer Data Organization and management Engine Structure and Layer Tool Layer Function Layer Resource Layer Core Layer Platform Layer 3rd Party Libraries Resource Layer 资源层 Resource - How to Access My Data Offline Resource Importing Unify file access by defining a meta asset file format Assets are faster to access by importing preprocess Build a commposite asset file to refer to all resources GUID is an extra protection of reference Resource - Runtime Asset Manager Runtime Resource Management A virtual file system to load/unload assets by path reference Manage asset lifespan and reference handle system Resource - Manage Asset Life Cycle Memory management fo Resources - life cycle Different resources have different life cycles Limited memory requires release of loaded resources when possible Garbage collection and deferred loading is criticle features Function Layer 功能层 Function - How to Make World Alive tickMain() function tickLogic() tickCamera() tickMotor() tickController() tickAnimation() tickPhysics() etc… tickRender() tickRenderCamera() culling() rendering() postprocess() present() Function - Tick the Animation and Rendering In each tick(over-simplifed version) Fetch animation frame of character Drive the skeleton and skin of character Render process all rendering job in an iteration of render tick for each frame. Function - Heavy-duty Hotchpotch Function Layer provides major function modules for the game engine Object system (HUGE) Game Loop updates the systems periodically Game Loop is the key of reading code of game engine Blur the boundary between engine and game Camera, character and behavior Design extendable engin API for programer Function - Multi-Threading Core Layer 核心层 Core - Math Library Linear algebra Rotation, transition, scaling Matrix splines, quatemion Core - Math Efficiency 游戏内单独写数学库的原因，是为了提高效率。 Core - Data Structure and Containers Data Structure Vectors, maps, trees, etc. Customized outperforms STL Avoid FRAGMENT memory 基本结构都会进行重写，提高数据结构的使用效率和更好的进行内存管理 Containers Skeleton tree Animation frame sequence Core - Memory Management Major bottlenecks of game engine performence Memory Pool / Allocator Reduce cache miss Memory alignment Polymorphic Memory Resource (PMR) Core - Foundation of Game Engine Core layers provide utilities needed in various function modules Super high performance design and implementation High standard of coding Platform Layer Platform - Target on Different Platform 平台无关性，需要把平台间的差异排除，让开发者专注内容的开发 Platform - Graphics API Render Hardware Interface (RHI) Transparent different GPU architectures and SDK Automatic optimization of target platforms Platform - Hardware Architecture 不同平台（主机）硬件差异也需要处理（如CPU架构不同） Tool Layer 工具层 Tool - Allow Anyone to Create Game Unleash the Creatively Build upon game engine Create, edit and exchange game play assets Flexible of coding languages Tool - Digital Content Creation Why Layered Architecture? Decoupling and Reducing Complexity Lower layers are independent from upper layers Upper layers do not know how lower layers are implemented Response for Evolving Demands Upper layers evolve fast, but lower layers are stable How to Build a Game World - Data Organization and management What does a game world consist of? How should we describe these things? How are these things organized? Use games Battlefield as for an example Game ObjectsEverything is a Game Object (GO). Static Game Objects Shed, Stone, Shack, Watchtower, Boxes, etc. Environments Sky, Vegetation, Terrain, etc. Other Game Objects Ruler, Navigation mesh, Trigger Area, Air wall, etc. How to Describe a Game Object?If I want a drone: Shape (property) Position (property) Move (behavior) Capacity of battery (property) Etc. These can be classified as property and behavior. 12345678910111213class Drone{ public: /* Properties */ Vector3 position; float health; float fuel; ... /* Behavior */ void move(); void scout(); ...}; Inheritance1234567class ArmedDrone: public Drone{ public: float ammo; void fire();} Component BaseThe components of a Drone: Transform Motor Model AI Animation Physics Etc. Compare a Drone and a Armed Drone: Components of a Drone Components of a Armed Drone Transform $=$ Transform Model $=$ Model Animation $=$ Animation Physics $=$ Physics … … AI $\\not=$ AI Combat How to Make the World AliveRendering 渲染 Model, Material, Shader, Texture Light and Shadow Render Pipeline Sky, Terrain, etc Animation 动画 Basic Concepts of Animation Animation Structure and Pipeline Physics 物理 Basic concepts of Physics System Gameplay Applications Performance Optimization Gameplay 游戏性 Event System Scripts System Graph Driven Misc. System 特效系统 Effects Navigation Camera … Tool Set 工具集 C++ Reflection Data Schema Online Gaming 网络游戏 Lockstep Synchronization State Synchronization Consistency Advanced Technology Motion Matching Procedural Content Generation (PCG) Data-Oriented Programming (DOP) Job System Lumen Nanite","link":"/2022-c8e28cf7c095/"},{"title":"刷题笔记 - 力扣2055、599、682、162、1901","text":"一、蜡烛之间的盘子题目给你一个长桌子，桌子上盘子和蜡烛排成一列。给你一个下标从 0 开始的字符串 s ，它只包含字符 '*' 和 '|' ，其中 '*' 表示一个 盘子 ，'|' 表示一支 蜡烛 。 同时给你一个下标从 0 开始的二维整数数组 queries ，其中queries[i] = [lefti, righti]表示 子字符串 s[lefti...righti] （包含左右端点的字符）。对于每个查询，你需要找到 子字符串中 在 两支蜡烛之间 的盘子的 数目 。如果一个盘子在 子字符串中 左边和右边 都 至少有一支蜡烛，那么这个盘子满足在 两支蜡烛之间 。 比方说，s = &quot;||**||**|*&quot; ，查询 [3, 8] ，表示的是子字符串 &quot;*||**|&quot; 。子字符串中在两支蜡烛之间的盘子数目为 2 ，子字符串中右边两个盘子在它们左边和右边 都 至少有一支蜡烛。 请你返回一个整数数组 answer ，其中 answer[i] 是第 i 个查询的答案。 示例示例 1: 输入：s = “||***|”, queries = [[2,5],[5,9]] 输出：[2,3] 解释： - queries[0] 有两个盘子在蜡烛之间。 - queries[1] 有三个盘子在蜡烛之间。 示例 2: 输入：s = “||****||||*”, queries = [[1,17],[4,5],[14,17],[5,11],[15,16]] 输出：[9,0,0,0,0] 解释： - queries[0] 有 9 个盘子在蜡烛之间。 - 另一个查询没有盘子在蜡烛之间。 提示： 3 &lt;= s.length &lt;= 105 s 只包含字符 '*' 和 '|' 。 1 &lt;= queries.length &lt;= 105 queries[i].length == 2 0 &lt;= lefti &lt;= righti &lt; s.length 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/plates-between-candles 思路该题目根据描述和示例可以理解为子字符串中左右两端蜡烛之间的盘子数量，这样我们只用确定子字符串最左边与最右边的两个蜡烛位置，再统计他们之间的盘子数量即可。我们可以先对完整字符串进行预处理： 统计出每个位置左边的盘子数量，方便获取到两端蜡烛位置后，直接相减即可得到中间盘子数量； 统计出每个位置左右方向距离最近的蜡烛位置，方便在查询时确定范围。 统计每个位置左边的盘子数量时，因为我们知道字符串首位左边盘子数量为0，所以我们从第二个位置开始遍历，每次判断前一个位置是否为盘子，若是，则读取前一个位置的左边盘子数量并加一来作为当前位置左边盘子数量；否则，前一位置的左边盘子数量即为当前位置左边盘子数量，以此遍历结束。 统计左右方向最近蜡烛位置时，因为我们知道字符串首位左边方向和末尾右边方向时没有蜡烛的，可以先将这两个信息设为-1，证明当前方向不存在蜡烛。接着我们从字符串的第二位到末尾统计左边方向最近蜡烛位置，从字符串倒数第二位到首位来统计右边方向最近蜡烛的距离。 这三个统计操作可以放在一次遍历中进行完成。 与统计完成后，我们便可以根据查询数组逐个完成查询内容：获取到查询位置后，我们通过左右方向蜡烛位置来获取实际要统计的子字符串的范围，接着再通过相减两个端点蜡烛位置的左边盘子数量，得到两蜡烛之间的盘子数量；其中，在获取实际蜡烛范围的时候，两个端点无论哪边获取到-1位置，或者端点顺序重合或调换，均证明符合要求的盘子数量为0。 最后我们返回记录结果的数组即可。 该方法时间复杂度为$O(n+m)$，$n$和$m$分别为字符串长度和查询数量；空间复杂度为$O(n)$，我们需要存放预处理的统计结果。 代码C++12345678910111213141516171819202122232425262728293031323334353637383940class Solution {public: vector&lt;int&gt; platesBetweenCandles(string s, vector&lt;vector&lt;int&gt;&gt;&amp; queries) { int len = s.length(); // 记录每个点之前有多少个盘子 vector&lt;int&gt; panNum(s.length()); // 记录每个点左右最临近的蜡烛位置，若不存在则为-1 vector&lt;int&gt; left(len); vector&lt;int&gt; right(len); left[0] = s[0] == '|' ? 0 : -1; right[len-1] = s[len-1] == '|' ? len-1 : -1;; // 结果数组 vector&lt;int&gt; answer; // 统计每点左边的盘子数量 for(int i = 1; i &lt; len; i ++) { panNum[i] = s[i-1] == '*' ? panNum[i-1] + 1 : panNum[i-1]; left[i] = s[i] == '|' ? i : left[i-1]; right[len-1-i] = s[len-1-i] == '|' ? len-1-i : right[len-i]; } for(int i = 0; i &lt; queries.size(); i++) { // 查询范围 int first = queries[i][0]; int last = queries[i][1]; // 找出范围内的最大蜡烛两端 first = right[first]; last = left[last]; if(last &lt;= first || first == -1 || last == -1){ answer.push_back(0); }else { answer.push_back(panNum[last] - panNum[first]); } } return answer; }}; 二、两个列表的最小索引总和题目假设 Andy 和 Doris 想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。 你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设答案总是存在。 示例示例 1:输入: list1 = [&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;]，list2 = [&quot;Piatti&quot;, &quot;The Grill at Torrey Pines&quot;, &quot;Hungry Hunter Steakhouse&quot;, &quot;Shogun&quot;] 输出: [&quot;Shogun&quot;] 解释: 他们唯一共同喜爱的餐厅是“Shogun”。 示例 2:输入:list1 = [&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;]，list2 = [&quot;KFC&quot;, &quot;Shogun&quot;, &quot;Burger King&quot;] 输出: [&quot;Shogun&quot;] 解释: 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。 提示: 1 &lt;= list1.length, list2.length &lt;= 1000 1 &lt;= list1[i].length, list2[i].length &lt;= 30 list1[i] 和 list2[i] 由空格 ' ' 和英文字母组成。 list1 的所有字符串都是 唯一 的。 list2 中的所有字符串都是 唯一 的。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists 思路我们可以先建立一个哈希表来记录list1中每个餐厅名称和他们的索引值；之后再遍历list2来检查哈希表中是否存在list2中的餐厅，如果存在，则将索引值相加并与当前最小索引值比较：若小于当前索引值总和，则清空结果数组并将当前餐厅名称存入结果数组中；若等于当前索引值总和，则将当前餐厅加入结果数组中。 该方法时间复杂度为$O(n+m)$，$n$为list1的长度，$m$为list2的长度；空间复杂度为$O(n)$，我们需要$n$个空间去存储list1的信息。 代码C++1234567891011121314151617181920212223242526272829class Solution {public: vector&lt;string&gt; findRestaurant(vector&lt;string&gt;&amp; list1, vector&lt;string&gt;&amp; list2) { vector&lt;string&gt; result; int minIndex = list1.size() + list2.size() ; // &lt;餐厅名称，索引值&gt; unordered_map&lt;string, int&gt; restaurants; // 将list1中的餐厅和索引值存储 for(int i = 0; i &lt; list1.size(); i++) { restaurants[list1[i]] = i; } // 比较list2的餐厅以及对应索引值之和 for(int i = 0; i &lt; list2.size(); i++) { if(restaurants.find(list2[i]) != restaurants.end()) { int temp = restaurants[list2[i]] + i; if(temp &lt; minIndex) { result = {list2[i]}; minIndex = temp; }else if(temp == minIndex) { result.push_back(list2[i]); } } } return result; }}; 三、棒球比赛题目你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。 比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 ops，其中 ops[i] 是你需要记录的第 i 项操作，ops 遵循下述规则： 整数 x - 表示本回合新获得分数 x“+” - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。“D” - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。“C” - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。请你返回记录中所有得分的总和。 示例示例 1：输入：ops = [&quot;5&quot;,&quot;2&quot;,&quot;C&quot;,&quot;D&quot;,&quot;+&quot;] 输出：30 解释： &quot;5&quot; - 记录加 5 ，记录现在是 [5] &quot;2&quot; - 记录加 2 ，记录现在是 [5, 2] &quot;C&quot; - 使前一次得分的记录无效并将其移除，记录现在是 [5]. &quot;D&quot; - 记录加 2 * 5 = 10 ，记录现在是 [5, 10]. &quot;+&quot; - 记录加 5 + 10 = 15 ，记录现在是 [5, 10, 15]. 所有得分的总和 5 + 10 + 15 = 30 示例 2：输入：ops = [&quot;5&quot;,&quot;-2&quot;,&quot;4&quot;,&quot;C&quot;,&quot;D&quot;,&quot;9&quot;,&quot;+&quot;,&quot;+&quot;] 输出：27 解释： &quot;5&quot; - 记录加 5 ，记录现在是 [5] &quot;-2&quot; - 记录加 -2 ，记录现在是 [5, -2] &quot;4&quot; - 记录加 4 ，记录现在是 [5, -2, 4] &quot;C&quot; - 使前一次得分的记录无效并将其移除，记录现在是 [5, -2] &quot;D&quot; - 记录加 2 * -2 = -4 ，记录现在是 [5, -2, -4] &quot;9&quot; - 记录加 9 ，记录现在是 [5, -2, -4, 9] &quot;+&quot; - 记录加 -4 + 9 = 5 ，记录现在是 [5, -2, -4, 9, 5] &quot;+&quot; - 记录加 9 + 5 = 14 ，记录现在是 [5, -2, -4, 9, 5, 14] 所有得分的总和 5 + -2 + -4 + 9 + 5 + 14 = 27 示例 3：输入：ops = [&quot;1&quot;] 输出：1 提示： 1 &lt;= ops.length &lt;= 1000 ops[i] 为 &quot;C&quot;、&quot;D&quot;、&quot;+&quot;，或者一个表示整数的字符串。整数范围是 $[-3 * 10^4, 3 * 10^4]$ 对于 &quot;+&quot; 操作，题目数据保证记录此操作时前面总是存在两个有效的分数 对于 &quot;C&quot; 和 &quot;D&quot; 操作，题目数据保证记录此操作时前面总是存在一个有效的分数 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/baseball-game 思路我们可以新建栈或数组来记录每轮分数方便操作，推荐使用数组进行，遍历操作数组（ops）的时候若是&quot;C&quot;, &quot;D&quot;, &quot;+&quot;则进入各自的操作：&quot;C&quot;则将总分减去最后一个分数，并将其从分数记录中删去；&quot;D&quot;则翻倍最后一次分数并与总分相加；&quot;+&quot;对于栈的话操作较麻烦，需要获取pop一次分数获取两次顶层分数再将之前pop掉的分数添加回栈，而如果之前用的是数组记录分数的话则操作十分简单，直接获取最后两个分数再相加即可。其余直接转成整型与总分相加。 该方法时间复杂度为$O(n)$，因为需要遍历操作数组进行分数操作；空间复杂度为$O(n)，因为需要建立栈或者数组存储每轮分数。 代码C++12345678910111213141516171819202122232425262728293031323334class Solution {public: int calPoints(vector&lt;string&gt;&amp; ops) { stack&lt;int&gt; points; int total { 0 }; for(int i = 0; i &lt; ops.size(); i++) { if(ops[i] == &quot;C&quot;) { total -= points.top(); points.pop(); } else if(ops[i] == &quot;D&quot;) { int temp = points.top() * 2; points.push(temp); total += temp; } else if(ops[i] == &quot;+&quot;) { int temp1 = points.top(); points.pop(); int temp2 = points.top(); points.push(temp1); points.push(temp1 + temp2); total += points.top(); } else { int point = stoi(ops[i]); points.push(point); total += points.top(); } } return total; }}; 四、寻找峰值题目峰值元素是指其值严格大于左右相邻值的元素。 给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。 你可以假设 $nums[-1] = nums[n] = -∞ $。 你必须实现时间复杂度为$O(log n)$的算法来解决此问题。 示例示例 1：输入：nums = [1,2,3,1] 输出：2 解释：3 是峰值元素，你的函数应该返回其索引 2。 示例 2：输入：nums = [1,2,1,3,5,6,4] 输出：1 或 5 解释：你的函数可以返回索引 1，其峰值元素为 2； 或者返回索引 5， 其峰值元素为 6。 提示： $1 &lt;= nums.length &lt;= 1000$ $-231 &lt;= nums[i] &lt;= 231 - 1$ 对于所有有效的 $i$ 都有 $nums[i] != nums[i + 1]$ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-peak-element 思路题目要求使用$O(logn)$的时间复杂度来完成，所以首先想到的就是使用二分法来求解。 既然要通过二分法来求解，那我们我们如何判断顶峰在哪边呢？ 根据题目信息，该数组相邻元素不相等，而且如果一个点为顶峰的充要条件就是该点大于左右相邻的元素。那么我们在二分法求解的时候，在取到中点时，因为相邻的值不相等，必然会出现左右元素大于或小于中点元素，甚至中点就可能时顶点的情况。若中点时顶点我们直接返回该位置即可；若中点不是顶峰，则要么左&gt;中&gt;右或者左&lt;中&lt;右，无论是哪种情况，大于中点的一侧一定会存在至少一个顶峰。因为相邻元素不能相等，所以较大的一侧要么一直大于当前中点，这样边缘位置的元素即为顶峰；要么出现拐点，那么该点即为顶峰。 我们便可以顺着这个思路划分下去。 值得注意的是，int的范围是-2147483648 到 2147483647，所以我在使用C++中INT_MIN的时候要注意可能出现左 == 中或者中 == 右且都为$-2147483648$，这时候说明左边或者右边在数组外面，我们依然判断该方向的值小于“中点”。 该方法时间复杂度为$O(logn)$，空间复杂度为$O(1)$。 代码C++12345678910111213141516171819202122232425262728293031class Solution {public: int findPeakElement(vector&lt;int&gt;&amp; nums) { // 定义左右位置 int left = 0; int right = nums.size() - 1; int mid = 0; while(left &lt;= right) { mid = (left+right) / 2; int midVal = nums[mid]; // 获得中间位置左右两边的值 int preVal = mid-1 &lt; 0 ? INT_MIN : nums[mid-1]; int nextVal = mid + 1 == nums.size() ? INT_MIN : nums[mid+1]; // 如果该中间点已经为峰值，则直接返回 if(midVal &gt; preVal &amp;&amp; midVal &gt; nextVal) { return mid; } // 若不是顶峰，通过与临值比较判断舍弃哪一半。由于题目说明相邻不相等，所以若是相等的话只可能是该位数值与INT_MIN数值相等且前一位在数组范围外。 if(midVal &gt;= preVal) { left = mid + 1; }else { right = mid - 1; } } return mid; }}; 五、 找出顶峰元素 II题目一个 2D 网格中的 顶峰元素 是指那些 严格大于 其相邻格子(上、下、左、右)的元素。 给你一个 从 0 开始编号 的 m x n 矩阵 mat ，其中任意两个相邻格子的值都 不相同 。找出 任意一个 顶峰元素 mat[i][j] 并 返回其位置 [i,j] 。 你可以假设整个矩阵周边环绕着一圈值为 $-1$ 的格子。 要求必须写出时间复杂度为 $O(m log(n))$ 或 $O(n log(m))$ 的算法 示例示例 1: 输入: mat = [[1,4],[3,2]] 输出: [0,1] 解释: 3和4都是顶峰元素，所以[1,0]和[0,1]都是可接受的答案。 示例 2: 输入: mat = [[10,20,15],[21,30,14],[7,16,32]] 输出: [1,1] 解释: 30和32都是顶峰元素，所以[1,1]和[2,2]都是可接受的答案。 提示： $m == mat.length$ $n == mat[i].length$ $1 &lt;= m, n &lt;= 500$ $1 &lt;= mat[i][j] &lt;= 105$ 任意两个相邻元素均不相等. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-a-peak-element-ii 思路这道题是“寻找峰值”的进阶版，从一维展开到二维。一维的思路我们可以二分法比较左右两边的大小，取大的半区在进行比较，获得最终峰值。二维数组无法直接这么做，因为我们即使先二分法定位一次列（行），也无法很好的定位该列（行）上的各个元素的周围大小比较。 所以我们可以换一个思路，在二分法获取比较列（行）之后，将该列（行）的最大值与其前后（列）行的最大值比较。因为最大值在本身的列（行）处于峰值，所以如果它再比前后行（列）的最大值更大，就说明它肯定大于它四周的所有元素，即它就是所求峰值。 思路清晰之后，我们需要写一个可复用的方法 - getMaxValAndPos（），获得当前列（行）的最大值和最大值的位置。我这里是通过二分法比较各行之间的最大值，所以是获得当前行的最大值以及最大值位置，也就是所在列的坐标，如果超出了数组的范围，根据题目的说明则直接返回最大值为$-1$，列数可以自己定义返回值，我定义的返回值也为$-1$。 之后就是跟一维求峰值类似的操作。只是将一维比较的元素改为当前行的最大值即可同时每次获取当前最大值的时候更新 peak 的坐标值。即可完成算法。 该方法时间复杂度为$O(nlog(m))$，$m$为矩阵行数，$n$为矩阵列数，因为寻找当前行最大值和位置时间复杂度为$O(n)$，二分法行数时间复杂度为$O(log(m))$。 代码C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution {public: // 获取 row 行的最大值以及最大值的位置，即为列值，若 row 不再有效范围，返回{-1,-1} vector&lt;int&gt; getMaxValAndPos(vector&lt;vector&lt;int&gt;&gt;&amp; mat, int row) { if(row &lt; 0 || row &gt; mat.size()-1 ) { return {-1, -1}; }else { int maxVal = 0; int pos = 0; for(int i = 0; i &lt; mat[row].size(); i++) { if(mat[row][i] &gt; maxVal) { maxVal = mat[row][i]; pos = i; } } return {maxVal, pos}; } } vector&lt;int&gt; findPeakGrid(vector&lt;vector&lt;int&gt;&gt;&amp; mat) { // 上下范围的初始位置 int top = 0; int bottom = mat.size() - 1; int mid = (top + bottom) / 2; // mid极值点作为初始 peak 点 vector&lt;int&gt; peak { mid, getMaxValAndPos(mat, mid)[1]}; int currentPeakVal = getMaxValAndPos(mat, mid)[0]; while(top &lt;= bottom) { vector&lt;int&gt; prePeakVal = getMaxValAndPos(mat, mid-1); vector&lt;int&gt; nextPeakVal = getMaxValAndPos(mat, mid+1); // 若满足条件则直接返回 if((currentPeakVal &gt; prePeakVal[0]) &amp;&amp; (currentPeakVal &gt; nextPeakVal[0]) ) { return peak; } // 若当前极值点大于某半区，则可以将范围锁定在另一半区 if(currentPeakVal &gt; prePeakVal[0]) { top = mid + 1; }else { bottom = mid - 1; } // 更新 mid 行以及 peak 点 mid = (top + bottom) / 2; peak[0] = mid; peak[1] = getMaxValAndPos(mat, mid)[1]; currentPeakVal = getMaxValAndPos(mat, mid)[0]; } return peak; }};","link":"/2022-44dac99071ee/"},{"title":"刷题笔记 - 力扣442、953、88、1021","text":"一、 数组中重复的数据题目给你一个长度为 n 的整数数组 nums ，其中 nums 的所有整数都在范围 [1, n] 内，且每个整数出现 一次 或 两次 。请你找出所有出现 两次 的整数，并以数组形式返回。 你必须设计并实现一个时间复杂度为 O(n) 且仅使用常量额外空间的算法解决此问题。 示例示例 1：输入：nums = [4,3,2,7,8,2,3,1] 输出：[2,3] 示例 2：输入：nums = [1,1,2] 输出：[1] 示例 3：输入：nums = [1] 输出：[] 提示： n == nums.length 1 &lt;= n &lt;= 105 1 &lt;= nums[i] &lt;= n nums 中的每个元素出现 一次 或 两次 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-all-duplicates-in-an-array 思路代码C++123456789101112131415class Solution {public: vector&lt;int&gt; findDuplicates(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; result; for(int i = 0; i &lt; nums.size(); i++) { int temp = abs(nums[i])-1; if(nums[temp] &lt; 0) { result.push_back(abs(nums[i])); }else { nums[temp] = -nums[temp]; } } return result; }}; 二、验证外星语词典题目某种外星语也使用英文小写字母，但可能顺序 order 不同。字母表的顺序（order）是一些小写字母的排列。 给定一组用外星语书写的单词 words，以及其字母表的顺序 order，只有当给定的单词在这种外星语中按字典序排列时，返回 true；否则，返回 false。 示例示例 1：输入：words = [&quot;hello&quot;,&quot;leetcode&quot;], order = &quot;hlabcdefgijkmnopqrstuvwxyz&quot; 输出：true 解释：在该语言的字母表中，'h' 位于 'l' 之前，所以单词序列是按字典序排列的。 示例 2：输入：words = [&quot;word&quot;,&quot;world&quot;,&quot;row&quot;], order = &quot;worldabcefghijkmnpqstuvxyz&quot; 输出：false 解释：在该语言的字母表中，'d' 位于 'l' 之后，那么 words[0] &gt; words[1]，因此单词序列不是按字典序排列的。 示例 3：输入：words = [&quot;apple&quot;,&quot;app&quot;], order = &quot;abcdefghijklmnopqrstuvwxyz&quot; 输出：false 解释：当前三个字符 &quot;app&quot; 匹配时，第二个字符串相对短一些，然后根据词典编纂规则 &quot;apple&quot; &gt; &quot;app&quot;，因为 'l' &gt; '∅'，其中 '∅' 是空白字符，定义为比任何其他字符都小（更多信息）。 提示： 1 &lt;= words.length &lt;= 100 1 &lt;= words[i].length &lt;= 20 order.length == 26 在 words[i] 和 order 中的所有字符都是英文小写字母。 来源：力扣（LeetCode）链接：https://leetcode.cn/problems/verifying-an-alien-dictionary 思路直接遍历words数组进行比较即可。每次取前后两个单词，逐个字母进行比较。同位置上若前一个单词的字母排序小于后一个，直接跳过当前循环去比较下一对单词；若大于，则可以直接返回false，否则，则继续比较下一个位置的字母。 该方法时间复杂度为$O(n*m)$，$n$为words的长度，$m$为words中单词长度的平均值；空间复杂度为$O(1)$。 代码C++123456789101112131415161718192021222324252627282930class Solution {public: bool isAlienSorted(vector&lt;string&gt;&amp; words, string order) { for(int i = 0; i &lt; words.size(); i++) { for(int j = i+1; j &lt; words.size(); j++) { // 获取第一个和第二个单词 string wordOne = words[i]; string wordTwo = words[j]; for(int k = 0; k &lt; wordOne.length(); k++) { // 若当前第一个单词的索引数已经超过了第二个单词，直接返回false if(k &gt; wordTwo.size()) { return false; } char letterOne = wordOne[k]; char letterTwo = wordTwo[k]; // 获取当前字母的序号 int orderOne = order.find_first_of(letterOne); int orderTwo = order.find_first_of(letterTwo); if(orderTwo &lt; orderOne) { return false; }else if(orderOne &lt; orderTwo) { break; } } } } return true; }}; 三、合并两个有序数组题目给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。 注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。 示例示例 1：输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 解释：需要合并 [1,2,3] 和 [2,5,6] 。 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。 示例 2：输入：nums1 = [1], m = 1, nums2 = [], n = 0 输出：[1] 解释：需要合并 [1] 和 [] 。 合并结果是 [1] 。 示例 3：输入：nums1 = [0], m = 0, nums2 = [1], n = 1 输出：[1] 解释：需要合并的数组是 [] 和 [1] 。 合并结果是 [1] 。 注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。 提示： nums1.length == m + n nums2.length == n 0 &lt;= m, n &lt;= 200 1 &lt;= m + n &lt;= 200 -109 &lt;= nums1[i], nums2[j] &lt;= 109 进阶：你可以设计实现一个时间复杂度为 O(m + n) 的算法解决此问题吗？ 来源：力扣（LeetCode）链接：https://leetcode.cn/problems/merge-sorted-array 思路时间复杂度要求$O(m + n)$以为着遍历一遍数组就需要排好序。而我们可以看到nums1和nums2都是已经排好序的数组，那我们可以通过双指针逐步比较两个数组的元素，形成一个新的数组，再赋值给nums1即可。 代码C++1234567891011121314151617181920212223242526272829class Solution {public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) { int i = 0; int j = 0; int temp; vector&lt;int&gt; result; while(i &lt; m || j &lt; n) { if(i == m &amp;&amp; j &lt; n) { temp = nums2[j]; j++; }else if(j==n &amp;&amp; i &lt; m) { temp = nums1[i]; i++; } else if(nums1[i] &lt; nums2[j]){ temp = nums1[i]; i++; }else { temp = nums2[j]; j++; } result.push_back(temp); } for(int k = 0; k &lt; m+n; k++) { nums1[k] = result[k]; } }}; 四、 删除最外层的括号题目有效括号字符串为空 &quot;&quot;、&quot;(&quot; + A + &quot;)&quot; 或 A + B ，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。 例如，&quot;&quot;，&quot;()&quot;，&quot;(())()&quot; 和 &quot;(()(()))&quot; 都是有效的括号字符串。如果有效字符串 s 非空，且不存在将其拆分为 s = A + B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。 给出一个非空有效字符串 s，考虑将其进行原语化分解，使得：s = P_1 + P_2 + ... + P_k，其中 P_i 是有效括号字符串原语。 对 s 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 s 。 示例示例 1：输入：s = &quot;(()())(())&quot; 输出：&quot;()()()&quot; 解释： 输入字符串为 &quot;(()())(())&quot;，原语化分解得到 &quot;(()())&quot; + &quot;(())&quot;， 删除每个部分中的最外层括号后得到 &quot;()()&quot; + &quot;()&quot; = &quot;()()()&quot;。 示例 2：输入：s = &quot;(()())(())(()(()))&quot; 输出：&quot;()()()()(())&quot; 解释： 输入字符串为 &quot;(()())(())(()(()))&quot;，原语化分解得到 &quot;(()())&quot; + &quot;(())&quot; + &quot;(()(()))&quot;， 删除每个部分中的最外层括号后得到 &quot;()()&quot; + &quot;()&quot; + &quot;()(())&quot; = &quot;()()()()(())&quot;。 示例 3：输入：s = &quot;()()&quot; 输出：&quot;&quot; 解释： 输入字符串为 &quot;()()&quot;，原语化分解得到 &quot;()&quot; + &quot;()&quot;， 删除每个部分中的最外层括号后得到 &quot;&quot; + &quot;&quot; = &quot;&quot;。 提示： 1 &lt;= s.length &lt;= 105 s[i] 为 '(' 或 ')' s 是一个有效括号字符串 来源：力扣（LeetCode）链接：https://leetcode.cn/problems/remove-outermost-parentheses 思路我们可以通过计数的方式来判断当前括号是否是最外层。遍历字符串，当遇到&quot;(&quot;时，计数器+1，若计数器此时大于1时，证明当前的正括号不属于最外层的括号，记录在结果中即可；每当遇到&quot;)&quot;时，计数器-1，若计数器此时为0，则证明当前反括号属于最外层括号，不记录到结果，其余情况反括号正常记录。即可得到最终“去掉外层括号”的字符串。 该方法时间复杂度为$O(n)$，$n$为字符串长度；空间复杂度为$O(1)$。 代码C++12345678910111213141516171819202122class Solution {public: string removeOuterParentheses(string s) { string result; int count { 0 }; for(int i = 0; i &lt; s.length(); i++) { if(s[i] == '(') { count++; if(count &gt; 1) { result += '('; } }else if(s[i] == ')') { count--; if(count != 0) { result += ')'; } } } return result; }};","link":"/2022-47ae5dfe2bee/"},{"title":"力扣232、225、150","text":"一、用栈实现队列题目请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）： 实现 MyQueue 类： void push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开头移除并返回元素 int peek() 返回队列开头的元素 boolean empty() 如果队列为空，返回 true ；否则，返回 false 说明： 你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top,size, 和 is empty 操作是合法的。 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 示例示例 1：12345678910111213输入：[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;][[], [1], [2], [], [], []]输出：[null, null, null, 1, 1, false]解释：MyQueue myQueue = new MyQueue();myQueue.push(1); // queue is: [1]myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)myQueue.peek(); // return 1myQueue.pop(); // return 1, queue is [2]myQueue.empty(); // return false 提示： 1 &lt;= x &lt;= 9 最多调用 100 次 push、pop、peek 和 empty 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作） 进阶： 你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。 大致思路 用两个栈即可实现队列的功能，一个栈为输入栈，另一个为输出栈。当我们在执行push操作时，直接将数据push进输入栈； 在执行pop和peek操作时，对输出栈的数据进行对应操作即可，如果输出栈为空，则将所有输入栈内的数据依次存入输出栈，则可实现输入栈中的数据倒序，从而实现队列的先进先出； empty操作则是判断输入输出栈是否均为空即可。 代码C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class MyQueue {private: stack&lt;int&gt; m_input; stack&lt;int&gt; m_output; void in2out() { while(!m_input.empty()) { m_output.push(m_input.top()); m_input.pop(); } }public: MyQueue() { } void push(int x) { m_input.push(x); } int pop() { if(m_output.empty()) { in2out(); } int temp = m_output.top(); m_output.pop(); return temp; } int peek() { if(m_output.empty()) { in2out(); } return m_output.top(); } bool empty() { return m_input.empty() &amp;&amp; m_output.empty(); }};/** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;peek(); * bool param_4 = obj-&gt;empty(); */ 来源：力扣（LeetCode）链接：https://leetcode.cn/problems/implement-queue-using-stacks 二、用队列实现栈题目请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。 实现 MyStack 类： void push(int x) 将元素 x 压入栈顶。 int pop() 移除并返回栈顶元素。 int top() 返回栈顶元素。 boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。 注意： 你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。 示例：12345678910111213输入：[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;][[], [1], [2], [], [], []]输出：[null, null, null, 2, 2, false]解释：MyStack myStack = new MyStack();myStack.push(1);myStack.push(2);myStack.top(); // 返回 2myStack.pop(); // 返回 2myStack.empty(); // 返回 False 提示： 1 &lt;= x &lt;= 9 最多调用100 次 push、pop、top 和 empty 每次调用 pop 和 top 都保证栈不为空 进阶：你能否仅用一个队列来实现栈。 来源：力扣（LeetCode）链接：https://leetcode.cn/problems/implement-stack-using-queues 大致思路与力扣232. 用栈实现队列类似，理解队列和栈就很好做。 队列是FIFO( First in first out )，栈是FILO( First in last out )。不像用栈模拟队列需要两个栈来操作，用队列模拟栈只需要一个队列即可。pop、top、empty没有特别的，只有在push的时候，每次push都需要将队列原来的元素重新依次进行pop和push操作，实现顺序颠倒，满足栈的FILO的顺序。 举个例子： 原队列 push操作 push后队列 重新push原队列数据 [ ] 1 [ 1 ] [ 1 ] [ 1 ] 2 [ 1, 2 ] [ 2, 1 ] [ 2, 1 ] 3 [ 2, 1, 3 ] [ 3, 2, 1 ] [ 3, 2, 1 ] 4 [ 3, 2, 1, 4 ] [ 4, 3, 2, 1 ] 代码C++12345678910111213141516171819202122232425262728293031323334353637383940414243class MyStack {private: queue&lt;int&gt; m_que;public: MyStack() { } void push(int x) { m_que.push(x); int size = m_que.size(); while(--size) { m_que.push(m_que.front()); m_que.pop(); } } int pop() { int temp = m_que.front(); m_que.pop(); return temp; } int top() { int temp = m_que.front(); return temp; } bool empty() { return m_que.empty(); }};/** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;top(); * bool param_4 = obj-&gt;empty(); */ 三、 逆波兰表达式求值题目根据 ** 逆波兰表示法**，求表达式的值。 有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 注意 两个整数之间的除法只保留整数部分。 可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 示例示例 1：输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;] 输出：9 解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9 示例 2：输入：tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;] 输出：6 解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6 示例 3：输入：tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;] 输出：22 解释：该算式转化为常见的中缀算术表达式为： ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 提示： 1 &lt;= tokens.length &lt;= 104 tokens[i] 是一个算符（&quot;+&quot;、&quot;-&quot;、&quot;*&quot; 或 &quot;/&quot;），或是在范围 [-200, 200] 内的一个整数 逆波兰表达式：逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。 平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。逆波兰表达式主要有以下两个优点： 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中 来源：力扣（LeetCode）链接：https://leetcode.cn/problems/evaluate-reverse-polish-notation 大致思路可以使用栈来进行操作，遍历给到的字符串向量，如果不是符号，就转换成整型存储在栈中；如果遇到运算符，则取出栈中前两个数据进行相应计算后，再储存进栈中。直到遍历结束，栈中的结果既是所求结果。时间复杂度和空间复杂度均为$O(n)$。 代码C++1234567891011121314151617181920212223242526272829303132333435363738class Solution {public: int evalRPN(vector&lt;string&gt;&amp; tokens) { stack&lt;int&gt; result; for(int i = 0; i &lt; tokens.size(); i++ ) { if(tokens[i] == &quot;+&quot; || tokens[i] == &quot;-&quot; || tokens[i] == &quot;*&quot; || tokens[i] == &quot;/&quot;) { int b = result.top(); result.pop(); int a = result.top(); result.pop(); if(tokens[i] == &quot;+&quot;) { result.push(a + b); } else if(tokens[i] == &quot;-&quot;) { result.push(a - b); } else if(tokens[i] == &quot;*&quot;) { result.push(a * b); } else if(tokens[i] == &quot;/&quot;) { result.push(a / b); } } else { result.push(stoi(tokens[i])); } } return result.top(); }};","link":"/2022-3af0c711a372/"},{"title":"数组中的逆序对","text":"剑指 Offer 51. 数组中的逆序对在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 来源：力扣（LeetCode）链接：https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof 想法通过归并排序，在归并过程中统计逆序对的数量即可。 因为在归并排序的时候，每一轮数组待统计的部分都会分成左右两个部分，且是已经从小到大排好序的。所以比较左右部分前端的两个元素时，若左边元素大于右边元素，则意味着左边剩余元素也大于右边该元素，即可统计出数量。 代码C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** 求逆序对数* @param vector&lt;int&gt; arr, 无序数组* @return int, 逆序对数量*/int ReversePairs(vector&lt;int&gt;&amp; arr){ if (arr.size() == 0 || arr.size() == 1) { return 0; } int L = 0, R = arr.size() - 1; return ReversePairsProcess(arr, L, R);}/** 逆序对递归处理* @param vector&lt;int&gt; arr, 无序数组* @param int L, int R, 需要计算的范围, 左右端的索引值* @return int, 计算得到的逆序对数量。*/int ReversePairsProcess(vector&lt;int&gt;&amp; arr, int L, int R){ if (L == R) { return 0; } int M = L + ((R - L) &gt;&gt; 1); int leftPairs = ReversePairsProcess(arr, L, M); int rightPairs = ReversePairsProcess(arr, M + 1, R); int currentPairs = ReversePairsMerge(arr, L, M, R); return leftPairs + currentPairs + rightPairs;}/** 归并左右范围并统计该范围内的逆序对数量* @param vector&lt;int&gt; arr, 无序数组* @param int L, int R, 需要统计的范围, 左右端的索引值* @return int, 逆序对数量。*/int ReversePairsMerge(vector&lt;int&gt;&amp; arr, int L, int M, int R){ int leftIndex = L, leftEnd = M; int rightIndex = M + 1, rightEnd = R; vector&lt;int&gt; helpArray(R - L + 1); int i{ 0 }; int pairs{ 0 }; while (leftIndex &lt;= leftEnd &amp;&amp; rightIndex &lt;= rightEnd) { // 只有左边的元素大于右边，才记录统计并记录数量；否则不计。 pairs += arr[leftIndex] &gt; arr[rightIndex] ? leftEnd - leftIndex + 1 : 0; // 归并排序常规操作。 helpArray[i++] = arr[leftIndex] &lt;= arr[rightIndex] ? arr[leftIndex++] : arr[rightIndex++]; } while (leftIndex &lt;= leftEnd) { helpArray[i++] = arr[leftIndex++]; } while (rightIndex &lt;= rightEnd) { helpArray[i++] = arr[rightIndex++]; } for (i = 0; i &lt; helpArray.size(); i++) { arr[L + i] = helpArray[i]; } return pairs;}/* 时间复杂度 O(N*logN), 可以通过递归函数MASTER公式计算; 空间复杂度 O(N), 需要临时空间来局部排序 */","link":"/2022-7be647f7d121/"},{"title":"荷兰国旗问题，或DNF、颜色分类问题","text":"荷兰国旗问题给定一个数组，和一个数。请把小于这个数的数放在数组的左边；等于这个数的数放在数组的中间；大于这个数的数放在数组的右边。求额外空间复杂度为$O(1)$。时间复杂度为$O(N)$。 想法我们需要三个指针：left，right 和 i。其中left和right指针分别在数组两头。left指针用来标记小于部分的区域，right指针用来标记大于部分的区域，i指针则用来遍历数组。 中心思想是： 如果i位置的值小于num, 则跟小雨范围的元素对换位置, left 和 i一起右移; 如果i位置的值大于num, 则跟大于范围的元素对换位置, right单独左移一位; 如果i位置的值等于num, 则只有i右移. 整个过程如果脑补不出来，可以在纸上走一遍即可非常清晰。 代码C++12345678910111213141516171819202122232425262728void DutchNationalFlagProblem(vector&lt;int&gt;&amp; arr, int num){ // 获得数组首尾索引值. left 作为小于范围的指针位置; right 作为大于范围的指针位置. int left = 0, right = arr.size() - 1; // 移动的指针 int i = 0; while (i &lt;= right) { /* * 如果 i 位置的值小于 num, 则跟小雨范围的元素对换位置, left 和 i 一起右移; * 如果 i 位置的值大于 num, 则跟大于范围的元素对换位置, right 单独左移一位; * 如果 i 位置的值等于 num, 则只有 i 右移. */ if (arr[i] &lt; num) { swap(arr[i++], arr[left++]); } else if (arr[i] &gt; num) { swap(arr[i], arr[right--]); } else { i++; } }} 补充类似的问题也可以参考力扣75题：颜色分类，或者是快速排序的思想。","link":"/2022-4665ea6af914/"},{"title":"反转链表","text":"反转链表给定单链表的头节点 head ，请反转链表，并返回反转后的链表的头节点。 可参考力扣相关题目： 剑指 Offer 24. 反转链表 剑指 Offer II 024. 反转链表 想法可以通过一个前指针，一个当前指针以及一个临时的后指针来完成链表反转。 初始状态下，前指针指向nullptr，当前指针指向 head。只要当前指针不为空，就可以用一个临时的后指针来表示下一个节点，修改当前节点的next为前一节点，再让前一节点等于当前节点，当前节点等于下一个节点。如此循环即可。（操作顺序不能乱） 最后返回前指针指向的节点即可，因为当前指针指向的是上一轮的nullptr。 代码C++1234567891011121314151617181920212223242526/** 节点定义* struct ListNode {* int val;* ListNode *next;* ListNode() : val(0), next(nullptr) {}* ListNode(int x) : val(x), next(nullptr) {}* ListNode(int x, ListNode *next) : val(x), next(next) {}* };*/ListNode* ReverseList(ListNode* head){ // 定义一个前置指针和一个当前指针 ListNode* left = nullptr; ListNode* current = head; // 如果当前指针不为空，则建立一个 next 指针记录下一个指针，并让当前指针指向前置指针。前置指针和当前指针各往前移动一位 while (current != nullptr) { ListNode* next = current-&gt;next; current-&gt;next = left; left = current; current = next; } return left;}","link":"/2022-301cedcf98f4/"},{"title":"复制带随机指针的链表","text":"复制带随机指针的链表给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。 构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点 **。 力扣相关题目： 复制带随机指针的链表 剑指 Offer 35. 复杂链表的复制 想法最基本的链表节点的结构如下： 123456789101112class Node {public: int val; Node* next; Node* random; Node(int _val) { val = _val; next = NULL; random = NULL; }}; 最简单暴力的遍历然后一个个复制用哈希表记录random指针再连接的方法就不说了。 说另一个方法，就是将新建的每个节点，我们可以将每个节点复制的新节点，先插入到原来的链表中，之后在链接random指针，最后在将原链表和复制链表分离开。这样的好处是可以只使用$O(1)$的空间复杂度。 全过程只需要遍历链表三遍或两遍： 第一遍遍历：复制节点，并在复制的同时将新建的节点插在原节点后面。比如原链表为$node1-&gt;node2-&gt;node3$，第一遍遍历完链表变成$node1-&gt;node1^\\prime-&gt;node2-&gt;node2^\\prime-&gt;node3-&gt;node3^\\prime$。 第二遍遍历：完成random指针的指向。因为每个新节点都跟在原节点的下一个。那么$node-&gt;next$就是$node^\\prime$节点；$node-&gt;random-&gt;next$即为$node^\\prime$节点所需要指向的random节点。 第三遍遍历：分离原节点和复制节点。处理好random节点后，再处理next节点的指向，即可完成分离。这一部也可以在第二遍遍历的时候同时完成。 代码C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/*// Definition for a Node.class Node {public: int val; Node* next; Node* random; Node(int _val) { val = _val; next = NULL; random = NULL; }};*/class Solution {public: Node* copyRandomList(Node* head) { // 如果链表为空则直接返回空指针 if(head == nullptr) { return nullptr; } // 第一遍遍历 for(Node* oldNode = head; oldNode != nullptr; oldNode = oldNode-&gt;next-&gt;next) { // 新建节点 Node* newNode = new Node(oldNode-&gt;val); // 先将新节点指向原来节点的下一位, 再将原节点指向新节点 newNode-&gt;next = oldNode-&gt;next; oldNode-&gt;next = newNode; } // 第二遍遍历 for(Node* oldNode = head; oldNode != nullptr; oldNode = oldNode-&gt;next-&gt;next) { // 如果旧节点存在 random 指针, 则让新节点也指向对应的新节点 if(oldNode-&gt;random != nullptr) { oldNode-&gt;next-&gt;random = oldNode-&gt;random-&gt;next; } } // 新建待返回的新链表头节点 Node* newHead = head-&gt;next; // 第三遍遍历 for(Node* oldNode = head; oldNode != nullptr; oldNode = oldNode-&gt;next) { // 获得当前节点的复制新节点 Node* newNode = oldNode-&gt;next; // 连接原节点与其原 next 节点 oldNode-&gt;next = newNode-&gt;next; // 如果当前原节点不是尾节点, 则处理新节点的 next 指向 if(oldNode-&gt;next != nullptr) { newNode-&gt;next = oldNode-&gt;next-&gt;next; } } return newHead; }};","link":"/2022-bf01eb6e95c4/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"力扣","slug":"力扣","link":"/tags/%E5%8A%9B%E6%89%A3/"},{"name":"Algorithm","slug":"ALGORITHM","link":"/tags/ALGORITHM/"},{"name":"Leetcode","slug":"LEETCODE","link":"/tags/LEETCODE/"},{"name":"书单","slug":"书单","link":"/tags/%E4%B9%A6%E5%8D%95/"},{"name":"Book List","slug":"BOOK-LIST","link":"/tags/BOOK-LIST/"},{"name":"游戏","slug":"游戏","link":"/tags/%E6%B8%B8%E6%88%8F/"},{"name":"游戏引擎","slug":"游戏引擎","link":"/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"游戏开发","slug":"游戏开发","link":"/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"},{"name":"Games","slug":"GAMES","link":"/tags/GAMES/"},{"name":"Game Engine","slug":"GAME-ENGINE","link":"/tags/GAME-ENGINE/"},{"name":"Game Develop","slug":"GAME-DEVELOP","link":"/tags/GAME-DEVELOP/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Data Structure","slug":"DATA-STRUCTURE","link":"/tags/DATA-STRUCTURE/"}],"categories":[{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]}