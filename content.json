{"pages":[{"title":"","text":"Xiangyun’s Blog作为文章记录、更新和备份的私有库，只保证文章备份，博客框架、主题修改等记录在 blog 仓库中。","link":"/readme"},{"title":"","text":"","link":"/about/"}],"posts":[{"title":"Xiangyun&#39;s Blog 重新连接","text":"Hello world！Hello Hexo！ 兜兜转转，最后还是通过 Github Pages和 Hexo 搭建了个人博客。不过 Github Pages 中国大陆访问越来越不稳定了，也考虑把博客部署到 Gitee 上，有空再研究。 虽然放在 Github，但是博客并不打算局限于做技术博客，而是想写什么就写什么，风格不限、体裁不限、内容不限。 博客还有很多要完善的地方，即便是 Hexo 的静态页面，但是看上去还是有特别多的地方值得研究，慢慢来吧。 距离2022只剩下的小半年，但仍旧能够惊艳。","link":"/2021-9f238081d6ce/"},{"title":"刷题笔记 - 无重复字符的最长子串","text":"题目给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 示例示例一输入: s = &quot;abcabcbb&quot; 输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例二输入: s = &quot;bbbbb&quot; 输出: 1 解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例三输入: s = &quot;pwwkew&quot; 输出: 3 解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 示例四输入: s = &quot;&quot; 输出: 0 提示： 0 &lt;= s.length &lt;= 5 * 104 s 由英文字母、数字、符号和空格组成 题目来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters 个人思路用一个变量记录“无重复字符的最长子串”的长度，再用两个变量作为子串的起始和末尾的位置。整个字符串逐个检查，若当前字符在子字符串中没有出现，则子串起始位置不变，末尾位置+1（末尾位置移到当前字符位置）；若当前字符在子串中出现，则与当前子串长度是否大于记录的“无重复字符的最长子串”的长度进行比较，判断是否要更新，再将子串起始位置更新至子串中当前字符重复字符的下一位，末尾位置+1（与另种情况一样）。 整个字符串遍历完成后，比较当前子串长度与记录的“无重复字符的最长子串”的长度，检查是否需要更新。最后返回最终的结果。 代码C++代码：123456789101112131415161718192021222324252627282930313233343536class Solution {public: int lengthOfLongestSubstring(string s) { // 判断是否为控制符串，若是直接返回0。 if(s.length() == 0) { return 0; } int start{0}; int end{0}; int maxLen{0}; for(int i = 0; i &lt; s.length(); i++) { end = i; // 由于其实是从0开始，左右这里的长度并不包含当前字符。 int len = end - start; string subString = s.substr(start, len); // 若当前字符已经在子串中出现过。 if(subString.find(s[i]) != string::npos) { if(maxLen &lt; len) { maxLen = len; } // 起始位置移至重复字符的下一位。 start = start + subString.find(s[i]) + 1; } } // 判断当前子串长度是否大于记录的最大长度，防止子串一直到结束都没有重复从而没有更新最大长度。 return maxLen &gt; (end - start +1) ? maxLen : (end - start +1); }}; 注意事项std::string 中size() 和 length() 没有区别，都是返回字节数。 string::npos 表示 string 的结束位置，find() 找不到指定值的时候会返回string::npos，所以可以用来判断是否找到所需的值。","link":"/2021-aa7d6baca413/"},{"title":"2021年书单目录","text":"封面 信息 进度 《一句顶一万句》 作者：刘震云 出版社：长江文艺出版社 https://book.douban.com/subject/26877012/ - 《虚拟偶像爱朵露》 作者：[美] 威廉·吉布森 出版社：新星出版社 https://book.douban.com/subject/25725500/ - 《雪崩》 作者：[美] 尼尔·斯蒂芬森 出版社：四川科学技术出版社 https://book.douban.com/subject/27097409/ - 《富野由悠季的影像原则》 作者： [日] 富野由悠季 出版社：浙江大学出版社 https://book.douban.com/subject/35349490/ 第四章读完， 共十二章 《故事》 作者：[美] 罗伯特·麦基 出版社: 天津人民出版社 https://book.douban.com/subject/25976544/ 第一章在读","link":"/2021-59df9e5f512b/"},{"title":"刷题笔记 - 最长公共前缀","text":"题目编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例示例 1：输入：strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;] 输出：&quot;fl&quot; 示例 2：输入：strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;] 输出：&quot;&quot; 解释：输入不存在公共前缀。 提示： 1 &lt;= strs.length &lt;= 200 0 &lt;= strs[i].length &lt;= 200 strs[i] 仅由小写英文字母组成 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-common-prefix 个人思路 若传入数组长度为0或者仅有1个字符串，则直接返回 “” 或者该字符串； 之后便是将第一个字符串上的字符逐个设为待比较字符，遍历每个字符串逐个进行比较： 若比较过程中发现有空字符串则直接返回 “” ； 若发现当前比较的字符串中索引值超过某个字符串长度，则返回当前已确定的最长公共前缀。 发现有不同的字符也可以直接终止比较并返回当前已确定的最长公共前缀。 该方法说白了就是每个字符串逐个字符同时比较；所以另一种方法则是通过两个两个字符串逐个比较最长公共前缀，这里就不再赘述。 该方法时间复杂度为 O(mn)，m和n分别为传入数组的字符串个数和字符串的平均长度；空间复杂度为O(1)。 官方给出了另外两种方法，一个是分治一个是二分查找，但是这两种方法时间复杂度或空间复杂度并没有优势，且想法没有之前的方法直接，就不去过多关注了。但是自己写的代码还是可以参考改进的。 代码C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution {public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) { int num = strs.size(); if(num &lt;= 1) { // 若数组为0，返回&quot;&quot;；若为1，返回第一个字符串。 return num == 0 ? &quot;&quot;: strs[0]; } // 记录最长公共前缀 string lcStr{&quot;&quot;}; // 临时比较的字符 char temp{}; bool isEnd{false}; // 只用取第一个字符串的长度为最长循环次数即可 int length = strs[0].size(); for(int j = 0; j &lt; length; j++) { for(int i = 0; i &lt; num; i++) { if(strs[i] == &quot;&quot;) { return &quot;&quot;; } // 若是第一个字符串，则将该字符串相应位置的字符记为被判断字符，否则比较当前字符和被判断字符 if(i == 0) { temp = strs[i][j]; } else { // 若发现判断字符和当前字符不相等，直接结束循环返回当前已确定的前缀。 if(temp != strs[i][j]) { return lcStr; } // 若当前为数组的最后一个字符串且相等，则将被判断字符加入最长公共前缀中。 else if( i == num -1) { lcStr += temp; } } } } return lcStr; }}; C++（官方题解）12345678910111213141516171819class Solution {public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) { if (!strs.size()) { return &quot;&quot;; } int length = strs[0].size(); int count = strs.size(); for (int i = 0; i &lt; length; ++i) { char c = strs[0][i]; for (int j = 1; j &lt; count; ++j) { if (i == strs[j].size() || strs[j][i] != c) { return strs[0].substr(0, i); } } } return strs[0]; }};","link":"/2021-cd5b0f8c43a7/"},{"title":"刷题笔记 - 罗马数字转整数","text":"题目罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。 示例示例一输入: s = &quot;III&quot; 输出: 3 示例二输入: s = &quot;IV&quot; 输出: 4 示例三输入: s = &quot;IX&quot; 输出: 9 示例四输入: s = &quot;LVIII&quot; 输出: 58 解释: L = 50, V= 5, III = 3. 示例五输入: s = &quot;MCMXCIV&quot; 输出: 1994 解释: M = 1000, CM = 900, XC = 90, IV = 4. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/roman-to-integer 个人思路从罗马数字字符串末尾开始向前判断，若为‘I，X，C’时则判断其右边位数的值，来进行累加或者累减。但是这个思路有点暴力破解，等于将每个条件都进行判断。而实际只需用按顺序判断前一个字符所代表的数字是否小于后一个字符即可，若小于则累减，否则累加。 代码C++代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution { public: int romanToInt(string s) { // 累加数字 int total{0}; for(int i=s.length()-1 ; i &gt;= 0; i--) { int isMinus{ 1 }; switch(s[i]) { case 'I': if(s[i+1] == 'V' || s[i+1] == 'X') { isMinus = -1; } total += isMinus * 1; break; case 'V': total += 5; break; case 'X': if(s[i+1] == 'L' || s[i+1] == 'C') { isMinus = -1; } total += isMinus * 10; break; case 'L': total += 50; break; case 'C': if(s[i+1] == 'D' || s[i+1] == 'M') { isMinus = -1; } total += isMinus * 100; break; case 'D': total += 500; break; case 'M': total += 1000; break; } } return total; } }; 官方题解C++代码123456789101112131415161718192021222324252627class Solution {private: unordered_map&lt;char, int&gt; symbolValues = { {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000}, };public: int romanToInt(string s) { int ans = 0; int n = s.length(); for (int i = 0; i &lt; n; ++i) { int value = symbolValues[s[i]]; if (i &lt; n - 1 &amp;&amp; value &lt; symbolValues[s[i + 1]]) { ans -= value; } else { ans += value; } } return ans; }};","link":"/2021-4dd8d59c8b20/"},{"title":"刷题笔记 - 有效的括号","text":"题目给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 示例示例 1：输入：s = &quot;()&quot; 输出：true 示例 2：输入：s = &quot;()[]{}&quot; 输出：true 示例 3：输入：s = &quot;(]&quot; 输出：false 示例 4：输入：s = &quot;([)]&quot; 输出：false 示例 5：输入：s = &quot;{[]}&quot; 输出：true 提示： 1 &lt;= s.length &lt;= 104 s 仅由括号 ‘()[]{}’ 组成 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/valid-parentheses 个人思路看到题目之后很直接就联想到了使用栈来解决，因为每队括号必须闭合且按顺序，所以栈的后进先出很容易就可以比较右括号与最近的左括号是否匹配。 而因为括号成对出现，所以可以优先判断下字符串长度，如果为奇数则可以直接返回False。（题目已给出条件字符串不会为空） 在遍历字符串的时候，左括号可以依次 push 进栈中；遇到右括号时，则可以比较栈里最顶部的左括号是否匹配。 遍历结束后若栈为空，则说明所有括号都匹配，字符串有效。 该方法时间复杂度为 O(n)，空间复杂度为 O(n)。 代码C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution {public: bool isValid(string s) { // 若长度为奇数直接返回false; if((s.length())%2 != 0) { return false; } stack&lt;char&gt; a; for(int i = 0; i &lt; s.length(); i++) { char temp = s[i]; switch(temp) { case '(': a.push('('); break; case ')': if(a.empty() || a.top() != '(') { return false; } else { a.pop(); } break; case '[': a.push('['); break; case ']': if(a.empty() || a.top() != '[') { return false; } else { a.pop(); } break; case '{': a.push('{'); break; case '}': if(a.empty() || a.top() != '{') { return false; } else { a.pop(); } break; } } return a.empty(); }};","link":"/2021-a5555f2e2be4/"},{"title":"刷题笔记 - 合并两个有序链表","text":"题目将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例示例 1：输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4] 示例 2：输入：l1 = [], l2 = [] 输出：[] 示例 3：输入：l1 = [], l2 = [0] 输出：[0] 提示： 两个链表的节点数目范围是 [0, 50] -100 &lt;= Node.val &lt;= 100 l1 和 l2 均按 非递减顺序 排列 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/merge-two-sorted-lists 个人思路简单暴力的方法，就是新建一个节点，然后逐一比较两个节点的大小，加到新建的这个节点后面。l1或l2也逐一后移，直到其中一个链表全部添加完（成空链），则退出循环并将另一个非空链表加到新建链表之后。该方法时间复杂度为O(n+m)，n，m为两个链表的长度；空间复杂度为O(1)。 代码C++123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { // 本来做了l1和l2的空链表判断，但是后面循环里面有了这个功能并处理了剩余链表，所以这里不需用再单独判断了。 // if(l1 == nullptr || l2 == nullptr) // { // return l1 == nullptr ? l2 : l1; // } // temp作为移动的节点将相应节点加到combine后面。 ListNode combine{}; ListNode *temp{ &amp;combine }; // 若两个链表都不为空，则比较两链表节点的大小，并加到combine后面。 while(l1 != nullptr &amp;&amp; l2 != nullptr) { if(l1-&gt;val &lt; l2-&gt;val) { temp-&gt;next = l1; l1 = l1-&gt;next; }else{ temp-&gt;next = l2; l2 = l2-&gt;next; } temp = temp-&gt;next; } // 剩下的链可以直接加到合成链的后面。 temp-&gt;next = l1==nullptr?l2:l1; return combine.next; }};","link":"/2021-11ff5ab6d926/"},{"title":"刷题笔记 - 删除有序数组中的重复项","text":"题目给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 示例示例 1：输入：nums = [1,1,2] 输出：2, nums = [1,2] 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。 示例 2：输入：nums = [0,0,1,1,1,2,2,3,3,4] 输出：5, nums = [0,1,2,3,4] 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 提示： 0 &lt;= nums.length &lt;= 3 * 104 -104 &lt;= nums[i] &lt;= 104 nums 已按升序排列 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array 个人思路一开始的时候没有太读懂题目。其实题目意思就是将数组不重复的元素有序放在前面，并返回个数。接着答案会根据返回的个数输出数组的前n项。这也就是为什么我们返回的是数目，当答案输出的确是数组。 我们可以用两个指针来对数组进行修改：一个快指针进行数组遍历；另一个慢指针进行数组修改。快慢指针从第二个元素开始，快指针开始遍历数组。若快指针与前一个元素不同，则更新慢指针上的元素为快指针的元素，然后慢指针向后移动；若快指针与前一个元素相同，则继续遍历，慢指针不动。遍历完数组之后，快指针位于修改完的数组元素的下一位，而由于数组是从0开始作为索引。所以此时慢指针的数字也是数组无重复元素的个数（长度）。 Ps：更新的时候可以加一条判断，若快指针和慢指针不相等时候才更新慢指针元素。因为如果快慢指针相等，没必要进行元素更新；只有快慢指针不相等的时候，证明快慢指针中间出现重复元素，此时才需要更新慢指针元素。 该方法时间复杂度为 O(n)，空间复杂度为 O(1)。 代码C++12345678910111213141516171819202122232425262728class Solution {public: int removeDuplicates(vector&lt;int&gt;&amp; nums) { // 若数组长度为0，则直接返回 if(nums.size() == 0) { return 0; } int fast{1}; int slow{1}; for(slow = 1; slow &lt; nums.size(); slow++) { if(nums[slow] != nums[slow-1]) { // 若快慢指针处于同一位置，则不用复制，只有不处于同一位置时，才说明中间存在重复数组，需要更新。 if(fast != slow) { nums[fast] = nums[slow]; } fast++; } } return fast; }};","link":"/2021-b6458af3f313/"},{"title":"刷题笔记 - 移除元素","text":"题目给你一个数组nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例示例 1：输入：nums = [3,2,2,3], val = 3 输出：2, nums = [2,2] 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 示例 2：输入：nums = [0,1,2,2,3,0,4,2], val = 2 输出：5, nums = [0,1,4,0,3] 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 提示： 0 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 50 0 &lt;= val &lt;= 100 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-element 个人思路跟昨天做的题目《删除有序数组中的重复项》的思路类似，这道题也使用双指针：一个指针在数组开头(start)，另个指针在数组末尾(end)。当 start 指针在 end 指针左边时，start 指针逐步右移，当 start 指针的元素与 val 的值相等时，与 end 指针元素互换，并让 end 指针左移一位；循环直到两个指针相遇( start - end &lt; 0)。 该方法时间复杂度为 O(n)，空间复杂度为 O(1)。 代码C++123456789101112131415161718192021222324252627class Solution {public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int len = nums.size(); if(len == 0) { return 0; } int start {0}; int end {len-1}; while(start - end &lt; 1) { if(nums[start] == val) { nums[start] = nums[end]; end--; }else { start++; } } return start; }};","link":"/2021-72f516a7ba25/"},{"title":"刷题笔记 - 实现 strStr()","text":"题目实现 strStr() 函数。 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。 说明：当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。 示例示例 1：输入：haystack = &quot;hello&quot;, needle = &quot;ll&quot; 输出：2 示例 2：输入：haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot; 输出：-1 示例 3：输入：haystack = &quot;&quot;, needle = &quot;&quot; 输出：0 提示： 0 &lt;= haystack.length, needle.length &lt;= 5 * 104 haystack 和 needle 仅由小写英文字符组成 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/implement-strstr 个人思路暴力解法最直接想到的是暴力解法，这种解法思路简单但是耗时较长。 首先判断 needle 为0 和 haystack 为0这两种特殊情况。接着遍历haystack字符串，与needle字符串首字符进行比较，若相等，则继续匹配下一个字符。当出现不相等的时候跳出比较循环继续遍历haystack字符串。若haystack字符串遍历结束后依然没有匹配，则返回 -1。 该方法的时间复杂度为 O(mn)，空间复杂度为 O(1)。 代码C++（暴力解法）123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: int strStr(string haystack, string needle) { if(needle.length() == 0) { return 0; } if(haystack.length() == 0) { return -1; } bool isEnd{true}; for(int i = 0; i &lt; haystack.length(); i++) { // 若首字符像同，则开始比较后续的字符 if(haystack[i] == needle[0]) { for(int j = 1; j &lt; needle.length(); j++) { // 若发现出现不一样的字符，则跳出循环，并取消结束标记。 if(haystack[i+j] != needle[j]) { isEnd = false; break; } isEnd = true; } // 若结束，跳出循环，返回 if(isEnd) { return i; } } } return -1; }};","link":"/2021-81f924ed69a4/"},{"title":"刷题笔记 - 搜索插入位置","text":"题目给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为 O(log n) 的算法。 示例示例 1:输入: nums = [1,3,5,6], target = 5 输出: 2 示例 2:输入: nums = [1,3,5,6], target = 2 输出: 1 示例 3:输入: nums = [1,3,5,6], target = 7 输出: 4 示例 4:输入: nums = [1,3,5,6], target = 0 输出: 0 示例 5:输入: nums = [1], target = 0 输出: 0 提示: 1 &lt;= nums.length &lt;= 104 -104 &lt;= nums[i] &lt;= 104 nums 为无重复元素的升序排列数组 -104 &lt;= target &lt;= 104 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/search-insert-position 个人思路要求使用时间复杂度为 O(log n) 的算法，又因为数组是有序数组，很自然而言的想到二分法的思路。通过比较目标值与中间位置的值的大小，不断缩小范围进行比较： 若target 大于 mid 的值，则 left 变为 mid + 1；反之若 target 小于 mid 的值，则 right 变为 mid - 1；若 target 等于 mid 的值，则可以直接返回 mid 的值。循环直到出现 right &lt; left 为止，证明 target 是在 right 和 left 之间，则返回 right + 1 （即 left）作为插入位置即可。 通过表格就可以很直观的描述过程。 情况一： Round Index 0 1 2 3 4 5 target value mid 和 target 比较 1 Value 2 4 6 8 10 12 5 - l m r - target &lt; m ( 5 &lt; 6) =&gt; r = m - 1 2 Value 2 4 6 8 10 12 5 - l, m r - target &gt; m ( 5 &gt; 2) =&gt; l = m + 1 3 Value 2 4 6 8 10 12 5 - l, r, m - target &gt; m ( 5 &gt; 4) =&gt; l = m + 1 4 Value 2 4 6 8 10 12 3 - r l - r &lt; l =&gt; return r + 1;( return l ) 情况二： Round Index 0 1 2 3 4 5 target value mid 和 target 比较 1 Value 2 4 6 8 10 12 11 - l m r - target &gt; m ( 11 &gt; 6) =&gt; l = m + 1 2 Value 2 4 6 8 10 12 11 - l m r - target &gt; m ( 11 &gt; 10) =&gt; l = m + 1 3 Value 2 4 6 8 10 12 11 - l, r, m - target &lt; m ( 11 &lt; 12 ) =&gt; r = m - 1 4 Value 2 4 6 8 10 12 11 - r l - r &lt; l =&gt; return r + 1;( return l ) 情况三： Round Index 0 1 2 3 4 5 target value mid 和 target 比较 1 Value 2 4 6 8 10 12 8 - l m r - target &gt; m ( 8 &gt; 6) =&gt; l = m + 1 2 Value 2 4 6 8 10 12 8 - l m r - target&lt; m ( 8 &lt; 10) =&gt; r = m - 1 3 Value 2 4 6 8 10 12 8 - l, r, m - target == m =&gt; return m; ( m 则为 target 搜索到的位置) 该方法时间复杂度为 O(log n)，空间复杂度为 O(1)。 代码C++12345678910111213141516171819202122232425262728class Solution {public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) { int left{ 0 }; int right = nums.size() - 1; while(right &gt;= left) { int mid = (left + right) / 2; int midVal = nums[mid]; if( midVal == target) { return mid; } if( target &gt; midVal) { left = mid + 1; } else if( target &lt; midVal) { right = mid - 1; } } return left; }};","link":"/2021-feaef45bedf4/"},{"title":"刷题笔记 - 最大子数组和","text":"题目给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组 是数组中的一个连续部分。 示例示例 1：输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2：输入：nums = [1] 输出：1 示例 3：输入：nums = [5,4,-1,7,8] 输出：23 提示： 1 &lt;= nums.length &lt;= 105 -104 &lt;= nums[i] &lt;= 104 进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-subarray 个人思路如果数组长度为1，则直接返回该元素。 否则从第二个元素开始，若前一个元素大于0，则将当前元素与前一个元素相加，把值更新到当前元素。比较当前元素的值与最大值，若大于最大值，则更新最大值。直到数组遍历完比，返回最大值即可。 该方法时间复杂度为 O(n)，空间复杂度为 O(1)。 示例： Round 最大值 初始 -2 1 -3 4 -1 2 1 -5 4 -2 1 -2 1 -3 4 -1 2 1 -5 4 1 -2&lt;0 2 -2 1 -2 4 -1 2 1 -5 41 1 -3+1 3 -2 1 -2 4 -1 2 1 -5 1 4 -2&lt;0 4 -2 1 -2 4 3 2 1 -5 4 4 -1+4 5 -2 1 -2 4 3 5 1 -5 4 5 2+3 6 -2 1 -2 4 3 2 6 -5 4 6 1+5 7 -2 1 -2 4 3 2 6 1 4 6 -5+1 8 -2 1 -2 4 3 2 6 1 5 6 4+1 代码C++1234567891011121314151617181920212223242526272829class Solution {public: int maxSubArray(vector&lt;int&gt;&amp; nums) { // 若长度为1直接返回结果 if(nums.size() &lt; 2) { return nums[0]; } // 将结果预设为第一个元素的值 int result = nums[0]; for(int i = 1; i &lt; nums.size(); i++) { // 若前一个元素大于零，当前元素与前一个元素相加，更新到当前元素 if(nums[i - 1] &gt; 0) { nums[i] += nums[i - 1]; } // 更新完之后若当前元素大于result，则更新 result if(result &lt; nums[i]) { result = nums[i]; } } return result; }};","link":"/2021-f0ffa6620951/"},{"title":"刷题笔记 - 二分查找","text":"题目给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例示例 1:​ 输入: nums = [-1,0,3,5,9,12], target = 9​ 输出: 4​ 解释: 9 出现在 nums 中并且下标为 4 示例 2:​ 输入: nums = [-1,0,3,5,9,12], target = 2​ 输出: -1​ 解释: 2 不存在 nums 中因此返回 -1 提示： 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/binary-search 个人思路这道题其实就是“搜索插入位置”题目的基础班，就基本的二分查找。其方法思路我在之前的《刷题笔记 - 搜索插入位置》已经解释的非常详细了，唯一的区别就是该题因为只是查找，不用返回插入的坐标，在结束循环之前没有返回的话证明数组内没有目标值，最后的返回值为-1即可。 代码C++123456789101112131415161718192021222324252627class Solution {public: int search(vector&lt;int&gt;&amp; nums, int target) { int left{0}; int right = nums.size() - 1; while (right &gt;= left) { int mid = (right + left) / 2; int midVal = nums[mid]; // 如果中点与目标值相等，直接返回索引 if (target == midVal) { return mid; } if (target &gt; midVal) { left = mid + 1; } else if (target &lt; midVal) { right = mid - 1; } } // 循环结束仍未有返回值证明数组中不含目标值 return -1; }};","link":"/2021-1c6946f785d6/"},{"title":"刷题笔记 - 长度最小的子数组","text":"题目给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [$nums_l$, $nums_{l+1}$, …, $nums_{r-1}$, $nums_r$] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 示例示例 1：输入：target = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 示例 2：输入：target = 4, nums = [1,4,4] 输出：1 示例 3：输入：target = 11, nums = [1,1,1,1,1,1,1,1] 输出：0 提示： 1 &lt;= target &lt;= 109 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 105 进阶：如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimum-size-subarray-sum 个人思路我们可以利用类似双指针的思想，通过start和end两个指针建立一个滑动窗口。 start和end初始位置均在数组开头，首先移动end指针，开始构建窗口。当滑动窗口里面的子数组和大于等于target的时候，我们比较当前最小长度值来判断是否需要更新最小长度；之后end指针不动，移动start指针位置，并判断是否需要更新子数组最小长度，直到窗口内子数组和小于目标值，再继续先后移动end指针。直到整个数组遍历完毕。下面用表格来进行详细步骤演示，将会更加直观。 2 3 1 2 4 3 sum target length start, end 2 7 0 2 3 1 2 4 3 sum target length start end 5 7 0 2 3 1 2 4 3 sum target length start end 6 7 0 2 3 1 2 4 3 sum target length start end 8 7 4 2 3 1 2 4 3 sum target length start end 6 7 4 2 3 1 2 4 3 sum target length start end 10 7 4 2 3 1 2 4 3 sum target length start end 7 7 3 2 3 1 2 4 3 sum target length start end 6 7 3 2 3 1 2 4 3 sum target length start end 9 7 3 2 3 1 2 4 3 sum target length start end 7 7 2 该方法因为只用遍历一遍数组，所以时间复杂度为 O(n)，空间复杂度为 O(1)。 代码C++12345678910111213141516171819202122232425262728293031class Solution {public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) { // 活动窗口首位初试位置 int start{0}; int end{0}; // 长度最小连续子数组长度 int len{0}; // 窗口长度内子数组和 int sum{0}; for(int end = 0; end &lt; nums.size(); end++) { sum += nums[end]; while (sum &gt;= target) { int tempLen = end - start + 1; // 若当前子数组长度小于已知子数组长度 if(len == 0 || tempLen &lt; len) { len = tempLen; } // 窗口起始位置右移 sum -= nums[start]; start++; } } return len; }};","link":"/2021-389bb543d17d/"},{"title":"刷题笔记 - 螺旋矩阵","text":"题目给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。 示例示例 1： 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,2,3,6,9,8,7,4,5] 示例 2： 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] 输出：[1,2,3,4,8,12,11,10,9,5,6,7] 提示： m == matrix.length n == matrix[i].length 1 &lt;= m, n &lt;= 10 -100 &lt;= matrix[i][j] &lt;= 100 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/spiral-matrix 个人思路本题其实可以等价于将矩阵一圈一圈从外到内去遍历元素。上方是行不变列从左到右；右侧是列不变行从上到下；下方是行不变列从右到左；左侧是列不变行从下到上。所以可以设置四个变量分别表示每一圈上下左右位置，将元素在这之间遍历并添加到返回数组里面即可。值得注意的一点是，由于最后一圈会形成一个点、一列或者一行，所以在每次循环四边的时候在下方和左侧需要加一个判断，检查是否上下和左右有重合，若有，则不需要重复遍历。 时间复杂度为 $O(mn)$，每个元素都便利了一遍；空间复杂度为 $O(mn)$，建立了一个长度为 mn 的数组。 代码C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution {public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int row = matrix.size(); int col = matrix[0].size(); // 上下左右的索引值 int top = 0; int bottom = row - 1; int left = 0; int right = col - 1; vector&lt;int&gt; result; while ( left &lt;= right &amp;&amp; top &lt;= bottom) { // 顶部从左到右 for (int i = left; i &lt;= right; i++) { result.push_back(matrix[top][i]); } // 右边从上到下 for (int i = top + 1; i &lt;= bottom; i++) { result.push_back(matrix[i][right]); } if (left &lt; right &amp;&amp; top &lt; bottom) { // 底部从右到左 for (int i = right - 1; i &gt;= left; i--) { result.push_back(matrix[bottom][i]); } // 左边从下到上 for (int i = bottom - 1; i &gt; top; i--) { result.push_back(matrix[i][left]); } } // 顶部下移一层 top++; // 右边左移一位 right--; // 底部上移一层 bottom--; // 左边右移一位 left++; } return result; }};","link":"/2021-0459ab2ad0bb/"},{"title":"刷题笔记 - 螺旋矩阵II","text":"题目给你一个正整数 n ，生成一个包含 1 到 $n_2$ 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 示例示例 1： 输入：n = 3 输出：[[1,2,3],[8,9,4],[7,6,5]] 示例 2：输入：n = 1 输出：[[1]] 提示： 1 &lt;= n &lt;= 20 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/spiral-matrix-ii 个人思路这道题其实思路与《螺旋矩阵》一样，给一个正整数 n ，实际上就等于是矩阵行列为 n ，之后便是类似于《螺旋矩阵》中的遍历操作，只不过将获取矩阵元素换成赋值给矩阵相应位置。具体过程可以参考之前的思路。 该方法时间复杂度为 $O(n^2)$，空间复杂度也为$O(n^2)$，创建了一个 $n * n$ 的矩阵。 代码C++12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution {public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) { vector&lt;vector&lt;int&gt;&gt; matrix(n, vector&lt;int&gt;(n)); int top = 0; int bottom = n - 1; int left = 0; int right = n - 1; int i = 1; while (top &lt;= bottom &amp;&amp; left &lt;= right) { // 上方从左到右 for (int j = left; j &lt;= right; j++) { matrix[top][j] = i++; } // 右侧从上到下 for (int j = top + 1; j &lt;= bottom; j++) { matrix[j][right] = i++; } if (top &lt; bottom &amp;&amp; left &lt; right) { // 下方从右到左 for (int j = right - 1;j &gt;= left; j--) { matrix[bottom][j] = i++; } // 左侧从下到上 for (int j = bottom - 1; j &gt; top; j--) { matrix[j][left] = i++; } } top++; bottom--; left++; right--; } return matrix; }};","link":"/2021-a03717f51003/"},{"title":"刷题笔记 - 移除链表元素","text":"题目给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。 示例示例 1： 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5] 示例 2：输入：head = [], val = 1 输出：[] 示例 3：输入：head = [7,7,7,7], val = 7 输出：[] 提示： 列表中的节点数目在范围 [0, 104] 内 1 &lt;= Node.val &lt;= 50 0 &lt;= val &lt;= 50 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-linked-list-elements 个人思路题目并不难，只要一遍遍历一边对比找到与目标值一样的节点将它删除即可。我们判断每个节点的下一个节点是否是目标值，如果是的话，就将当前节点指向下下个节点，并将当前节点的下一个节点释放，即可完成删除。因为每次都是判断下一个节点，所以我们需要给头节点增加一个 0 节点当作初始节点方便进行判断。返回的时候我们返回这个 0 节点的下一位即是头节点。 该方法时间复杂度为 $O(n)$，因为要遍历所有的元素；空间复杂度为 $O(1)$，只用到了常数的空间存储。 代码C++12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* removeElements(ListNode* head, int val) { // 在head前新建一个节点 ListNode *zero = new ListNode(0, head); ListNode *current = zero; // 若下一个节点的值为目标值，则跳过该节点连接下下个节点；否则移到下一个节点继续判断。 while (current-&gt;next != nullptr) { if (current-&gt;next-&gt;val == val) { // 设置一个指针指向将被删的节点 ListNode *temp = current-&gt;next; current-&gt;next = current-&gt;next-&gt;next; // 释放被删除节点内存 delete temp; }else { current = current-&gt;next; } } return zero-&gt;next; }};","link":"/2021-2e8c5214b017/"},{"title":"刷题笔记 - 反转链表","text":"题目给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 示例示例 1： 输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1] 示例 2： 输入：head = [1,2] 输出：[2,1] 示例 3：输入：head = [] 输出：[] 提示： 链表中节点的数目范围是 [0, 5000] -5000 &lt;= Node.val &lt;= 5000 进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-linked-list 个人思路迭代该方法是迭代的方式完成反转，首先新建一个空指针作为结尾。之后一边遍历链表元素，一边用该元素创建新的链表元素，并将next指针指向之前的元素。这样便可完成链表反转。 该方法时间复杂度为 $O(n)$，因为需要遍历整个链表；空间复杂度也为$O(n)$，因为一边遍历一边新建元素，并没改变原来head为首的这条链表，而是新建了 $n$个元素组成了新的链表，使这条新链表与原来的链表相反。 如果可以优化一下代码，不建立新的链表，而是直接通过中间变量调换改变原来的链表，则可将空间复杂度变成了$O(1)$。 递归改题目递归思路的关键点在要将下一个节点递归下去的同时，对节点进行逆转操作。 结束条件为： 1(head == nullptr || head-&gt;next == nullptr) 以此判断链表已到末尾或者本身是空链表，返回当前head即可得到原来链表的末节点（即所需链表的首节点）； 将下一节点进行传递是： 1ListNode *current = reverseList(head-&gt;next); 因为最终我们需要的是逆转后链表的首节点，所以这里的 current 其实一直存储的就是该值，我们便需要在这段代码和最终 return current 这段代码之间，完成当前 head 和 head-&gt;next 的逆转。 逆转的代码如下： 12head-&gt;next-&gt;next = head;head-&gt;next = nullptr; 在将自身节点的下一个节点指向自己后，断开自己指向下一个节点的链接。即将 head 和 head-&gt;next 两个节点由原来的单链表，构建成双链表，再断开原先的指向，重新变回单链表。 该方法时间复杂度为 $O(n)$；空间复杂度为 $O(n)$，因为递归深度为$n$。 代码C++ （迭代，新建链表）12345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* reverseList(ListNode* head) { ListNode *result = nullptr; ListNode* current = head; while (current != nullptr) { ListNode *temp = new ListNode(current-&gt;val, result); result = temp; current = current-&gt;next; } return result; }}; C++ （迭代，优化空间复杂度）12345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* reverseList(ListNode* head) { ListNode* result = nullptr; ListNode* current = head; while (current != nullptr) { ListNode* temp = current-&gt;next; current-&gt;next = result; result = current; current = temp; } return result; }}; C++ （递归）12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* reverseList(ListNode* head) { if ( head == nullptr || head-&gt;next == nullptr) { return head; } // current 实际上一直是原来链表的最后一位元素，但是不断将 head-&gt;next 传下去进行操作 ListNode *current = reverseList(head-&gt;next); // 让当前head的下个元素指向自己，并断开当前head指向下个元素的链接 head-&gt;next-&gt;next = head; head-&gt;next = nullptr; return current; }};","link":"/2021-102da1183e5d/"},{"title":"刷题笔记 - 删除链表的第N个结点","text":"题目给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 示例示例 1： 输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] 示例 2：输入：head = [1], n = 1 输出：[] 示例 3：输入：head = [1,2], n = 1 输出：[1] 提示： 链表中结点的数目为 sz 1 &lt;= sz &lt;= 30 0 &lt;= Node.val &lt;= 100 1 &lt;= n &lt;= sz 进阶：你能尝试使用一趟扫描实现吗？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list 个人思路最直接易懂的方式就是先遍历一遍确定链表长度（len），算出删除第几个结点，将该结点删除即可。 如果把 head 结点算成第0个结点，则待删除结点为 len - n 个；若 head结点算成第1个结点，则待删除结点为第 len - n + 1 个结点。 结点删除可以使用 node-&gt;next = node-&gt;next-&gt;next 来操作，然后将删除点内存释放即可。 该方法时间复杂度为$O(n)$，空间复杂度为$O(1)$。 进阶：用一趟扫描实现可以使用前后双指针的方式，来进行一趟扫描实现。前指针用来“探路”，后指针用来指向要删除的地方，倒数第n个结点，只要前后指针相隔n个位置，即可使得当前指针遍历完链表的时候，后指针的下一位既是要删除的结点。 以示例1为例，最终为如下状态： 1 2 3 4 5 后指针位置 待删除位置 前指针位置 该方法时间复杂度依然为$O(n)$，空间复杂度也是$O(1)$。 代码C++12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { // 记录链表长度 int len{0}; ListNode *temp = head; while(temp != nullptr) { len++; temp = temp-&gt;next; } // 计算出要删除的位置（链表第一位序数为0） int del = len - n; int i{-1}; // 建立一个前置结点 temp = new ListNode(0, head); ListNode *result = temp; while(i &lt; len) { // 若下一个为要删除的结点，则删除下一个结点并连接到下下个结点，并释放内存 if (i+1 == del) { ListNode *delPtr = temp-&gt;next; temp-&gt;next = temp-&gt;next-&gt;next; // 释放该点内存 delete delPtr; break; }else { temp = temp-&gt;next; i++; } } return result-&gt;next; }}; C++（进阶）12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { // 建立前置结点 ListNode *zero = new ListNode(0, head); // 初始化前后指针 ListNode *first = zero; ListNode *second = zero; while(first != nullptr) { first = first-&gt;next; if (n &gt;= 0) { n--; } else { second = second-&gt;next; } } ListNode *temp = second-&gt;next; // 删除 second-&gt;next 结点 second-&gt;next = second-&gt;next-&gt;next; // 释放 second-&gt;next 结点处内存 delete temp; return zero-&gt;next; }};","link":"/2021-e590b1b38112/"},{"title":"刷题笔记 - 环形链表","text":"题目给你一个链表的头节点 head ，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 如果链表中存在环，则返回 true 。 否则，返回 false 。 示例示例 1： 输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0 输出：true 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1 输出：false 解释：链表中没有环。 提示： 链表中节点的数目范围是 [0, 104] -105 &lt;= Node.val &lt;= 105 pos 为 -1 或者链表中的一个 有效索引 。 进阶：你能用 $O(1)$（即，常量）内存解决此问题吗？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/linked-list-cycle 个人思路我们可以使用快慢双指针来完成算法，并同时可以满足进阶要求——$O(1)$空间复杂度。 快慢双指针的思路是让快指针每次前移两个结点，慢指针前移一个结点，若链表中出现环，则快指针可以“追”上慢指针，使两个指针相等。否则快指针必然会先遍历完链表，使得自身结点或下一个结点为空指针。建立前置零结点是为了防止一开始快慢指针就相等，同时也让快指针以head为起点，循环一开始可以先判断自身是否为空接点，这样就可以不用提前判断空链表的情况。 该方法时间复杂度为$O(n)$，n为链表长度；空间复杂度为$O(1)$。 代码C++123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: bool hasCycle(ListNode *head) { // 建立前置结点 ListNode *zero = new ListNode(0, head); // 将快指针和慢指针分别初始化在 head 结点和前置结点作为起点 ListNode *fast = zero-&gt;next; ListNode *slow = zero; // 如果快慢指针没有相遇，便进入循环 while(fast != slow) { // 如果快指针本身或下一个结点为空指针，证明链表结束没有环 if(fast == nullptr || fast-&gt;next == nullptr) { return false; }else { // 快指针向前移动两个结点慢指针移动一个结点 fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; } } return true; }};","link":"/2021-5832d3f93986/"},{"title":"刷题笔记 - 加一","text":"题目给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例示例 1：输入：digits = [1,2,3] 输出：[1,2,4] 解释：输入数组表示数字 123。 示例 2：输入：digits = [4,3,2,1] 输出：[4,3,2,2] 解释：输入数组表示数字 4321。 示例 3：输入：digits = [0] 输出：[1] 提示： 1 &lt;= digits.length &lt;= 100 0 &lt;= digits[i] &lt;= 9 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/plus-one 个人思路先将数组最后一位数字加1，之后从后往前遍历数组。若非首位位置的数字大于等于10（等于10），则其前一位（index - 1）位置数字加1，自己则与10取余（或者减10）。若数组第一位为10，则自身变为0，并在数组开头添加一个1（ vector.insert(vector.begin(), 1)）。 该方法时间复杂度为$O(n)$，n 为数组长度；空间复杂度为$O(1)$，使用了常数空间。 代码C++1234567891011121314151617181920212223class Solution {public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) { int len = digits.size(); digits[len - 1] += 1; for(int i = len -1; i &gt; 0; i--) { // 若非第一位大于等于10，则向前进1，并取余 if(digits[i] &gt;= 10) { digits[i-1] += 1; digits[i] %= 10; } } // 遍历完后若第一位为10，则向前添加一位，并自身取余（即变为0） if(digits[0] &gt;= 10) { digits.insert(digits.begin(), 1); digits[1] %= 10; } return digits; }};","link":"/2022-680328a3e122/"},{"title":"刷题笔记 - 二进制求和","text":"题目给你两个二进制字符串，返回它们的和（用二进制表示）。 输入为 非空 字符串且只包含数字1和0。 示例示例 1:输入: a = &quot;11&quot;, b = &quot;1&quot; 输出: &quot;100&quot; 示例 2:输入: a = &quot;1010&quot;, b = &quot;1011&quot; 输出: &quot;10101&quot; 提示： 每个字符串仅由字符 ‘0’ 或 ‘1’ 组成。 1 &lt;= a.length, b.length &lt;= 10^4 字符串如果不是 “0” ，就都不含前导零。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/add-binary 个人思路如果精度满足的话我们可以直接将字符串的二进制转换成十进制数字，先加完之后再转换回二进制。但若是遇到了较长的二进制字符串，则很有可能会出现精度问题。 所以我在这里使用了类似竖式运算的方法，直接二进制相加减的策略，同位置的数字相加，逢二进一。 要做竖式运算，就想要给较短的字符串串首进行补“0”操作。算出两个字符串的长度差，再给较短的一边开头补“0”。 之后将两个字符串从后往前（从右往左）一步步相加：首先将字符转换成整型，由于二进制只有“0”和“1”，我就直接通过判断字符的方式进行转换；这里要注意，并不仅仅要同位置的两个数相加，我们还要设置一个进位数参与相加，以确保进位正确；相加完后，若结果大于1，则说明需要进位，将进位数更新为1，再让结果与2取余，便可以得到当前位置的结果；重复这一过程知道遍历完字符串。 最后，遍历完字符串之后我们需要判断进位数是否仍为1，若是，则需要在结果字符串开头补“1”。 该方法时间复杂度为$O(n)$，n为两字符串的较大值；空间复杂度为$O(1)$，除去返回值的字符串，我们使用了常数个空间。 代码C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution {public: string addBinary(string a, string b) { int lenA = a.length(); int lenB = b.length(); string result { &quot;&quot; }; // 进位值 int carry { 0 }; // 为短的字符串前补0 // 求出长度差 int diff = lenA - lenB; if( diff != 0) { // a短 if( diff &lt; 0) { diff = -diff; for(int i = 0; i &lt; diff; i++) { a = &quot;0&quot; + a; } } // b短 else if ( diff &gt; 0) { for(int i = 0; i &lt; diff; i++) { b = &quot;0&quot; + b; } } } // 相加 for(int i = a.length() - 1;i &gt;= 0;i--) { int tempA = a[i] == '0' ? 0 : 1; int tempB = b[i] == '0' ? 0 : 1; int temp = tempA + tempB + carry; // 若结果大于1，则证明需要进位 carry = temp &gt; 1 ? 1 : 0; // 若需要进位，则需要对当前位数跟2取余 result = carry == 1 ? to_string(temp % 2) + result : to_string(temp) + result; } // 先加完若仍需要进位，则在字符串前补1 if(carry == 1) { result = &quot;1&quot; + result; } return result; }};","link":"/2022-895a03ab871b/"},{"title":"刷题笔记 - 最后一个单词的长度","text":"题目给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中最后一个单词的长度。 单词 是指仅由字母组成、不包含任何空格字符的最大子字符串 示例示例 1：输入：s = &quot;Hello World&quot; 输出：5 示例 2：输入：s = &quot; fly me to the moon &quot; 输出：4 示例 3：输入：s = &quot;luffy is still joyboy&quot; 输出：6 提示： 1 &lt;= s.length &lt;= 104 s 仅有英文字母和空格 ‘ ‘ 组成 s 中至少存在一个单词 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/length-of-last-word 个人思路题目十分简单，我们可以获取字符串长度之后反向进行遍历。只需要解决遇到空格的问题即可。我是用一个布尔值去判断是否遇到了最后一个单词，遇到了最后一个单词前碰到空格直接跳过当前循环；遇到最后一个单词后再碰到空格则跳出循环，返回统计到的值。 当然也可以先使用while循环之类的方法先处理字符串末尾的空格，这样就可以不用在统计的时候判断当前空格是最后一个单词前还是后的问题，哪种选择就看个人喜好。 该方法时间复杂度为O(n)，n 为最后一个单词的长度；空间复杂度为O(1)，只用了常数空间。 代码C++1234567891011121314151617181920212223242526class Solution {public: int lengthOfLastWord(string s) { int len = s.length(); int count { 0 }; // 标记是否遇到了最后一个单词 bool metLastWord { false }; for(int i = len -1; i &gt;= 0; i--) { // 如果末尾有空格，在没遇到最后一个单词前跳过 if(s[i] == ' ' &amp;&amp; metLastWord != true) { continue; } // 遇到单词并且又遇到了空格，证明单词已经结束，直接跳出循环 if(s[i] == ' ' &amp;&amp; metLastWord == true) { break; } // 如果不是空格，则开始计数 if(s[i] != ' ' ) { count++; metLastWord = true; } } return count; }};","link":"/2022-147578f67db5/"},{"title":"刷题笔记 - 按键持续时间最长的键","text":"题目LeetCode 设计了一款新式键盘，正在测试其可用性。测试人员将会点击一系列键（总计 n 个），每次一个。 给你一个长度为 n 的字符串 keysPressed ，其中 keysPressed[i] 表示测试序列中第 i 个被按下的键。releaseTimes 是一个升序排列的列表，其中 releaseTimes[i] 表示松开第 i 个键的时间。字符串和数组的 下标都从 0 开始 。第 0 个键在时间为 0 时被按下，接下来每个键都 恰好 在前一个键松开时被按下。 测试人员想要找出按键 持续时间最长 的键。第i 次按键的持续时间为 releaseTimes[i] - releaseTimes[i - 1]，第 0 次按键的持续时间为 releaseTimes[0] 。 注意，测试期间，同一个键可以在不同时刻被多次按下，而每次的持续时间都可能不同。 请返回按键 持续时间最长 的键，如果有多个这样的键，则返回 按字母顺序排列最大 的那个键。 示例示例 1：输入：releaseTimes = [9,29,49,50], keysPressed = &quot;cbcd&quot; 输出：&quot;c&quot; 解释：按键顺序和持续时间如下： 按下 'c' ，持续时间 9（时间 0 按下，时间 9 松开） 按下 'b' ，持续时间 29 - 9 = 20（松开上一个键的时间 9 按下，时间 29 松开） 按下 'c' ，持续时间 49 - 29 = 20（松开上一个键的时间 29 按下，时间 49 松开） 按下 'd' ，持续时间 50 - 49 = 1（松开上一个键的时间 49 按下，时间 50 松开） 按键持续时间最长的键是 'b' 和 'c'（第二次按下时），持续时间都是 20 'c' 按字母顺序排列比 'b' 大，所以答案是 'c' 示例 2：输入：releaseTimes = [12,23,36,46,62], keysPressed = &quot;spuda&quot; 输出：&quot;a&quot; 解释：按键顺序和持续时间如下： 按下 's' ，持续时间 12 按下 'p' ，持续时间 23 - 12 = 11 按下 'u' ，持续时间 36 - 23 = 13 按下 'd' ，持续时间 46 - 36 = 10 按下 'a' ，持续时间 62 - 46 = 16 按键持续时间最长的键是 'a' ，持续时间 16 提示： releaseTimes.length == n keysPressed.length == n 2 &lt;= n &lt;= 1000 1 &lt;= releaseTimes[i] &lt;= 109 releaseTimes[i] &lt; releaseTimes[i+1] keysPressed 仅由小写英文字母组成 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/slowest-key 个人思路这题的题目很长，一定要耐心读题。题目难度不难，一个字符串表示按下的按键，另个列表表示松开的时间，题目中也给出了提示，第i个按键的持续时间为releaseTimes[i] - releaseTimes[i - 1]。要得出最长时间的按键，我们只需要遍历完字符串和列表，获得最大值即可。 在遍历的过程中，如果发现更大的持续时间，则可以更新最大的按键；如果遍历时发现当前时间与已知的最大时间相等，则继续比较当前按键与已知最大按键的ascii值，即可比较出按字母顺序排列最大的按键。（直接通过运算符比较字符即使通过ascii来比较） 该方法时间复杂度为$O(n)$，n为字符串长度（或列表长度，一样的）；空间复杂度为$O(1)$，使用了常数个空间。 Ps:一开始题目没看清楚，理解错了题意，把题目理解成了要求每个按键的累计总持续时长最长的按键。那么这里就顺便也说一下如果是这样的要求的解题思路。 因为需要统计每个按键累计的持续时间。所以我们需要建立一个map来记录按键和对应的时间。在遍历的时候，获得当前按键和持续时间之后，在map中寻找是否已存在记录，如果没存在，则新建一个；若存在，则将当前持续时间加到统计的时间中。获取到累计的时间之后再与已知的最大持续时间比较，来判断是否需要更新结果。 这样时间复杂度仍然为$O(n)$，但是空间复杂度则变为$O(n)$，因为建立了一个按键长度的map。 代码C++（原题）123456789101112131415161718192021222324252627class Solution {public: char slowestKey(vector&lt;int&gt;&amp; releaseTimes, string keysPressed) { // 用来记录最长的时间，初始化为第一个按键时长 int maxTime { releaseTimes[0] }; // 记录结果，初始化为第一个按键 char result { keysPressed[0] }; int times = releaseTimes.size(); for(int i = 0; i &lt; times; i++) { // 当前按键的按压时间 int pressedT = i==0? releaseTimes[i] : releaseTimes[i] - releaseTimes[i-1]; char currentKey = keysPressed[i]; if (pressedT &gt; maxTime) { result = currentKey; maxTime = pressedT; }else if(pressedT == maxTime) { if(currentKey &gt; result) { result = currentKey; } } } return result; }}; C++ （若题目改为累计持续时间最长）1234567891011121314151617181920212223242526272829303132333435363738class Solution {public: char slowestKey(vector&lt;int&gt;&amp; releaseTimes, string keysPressed) { // 用来记录最长的时间 int maxTime { 0 }; // 记录结果 char result; map&lt;char, int&gt; pressedTime; int times = releaseTimes.size(); for(int i = 0; i &lt; times; i++) { // 当前按键的按压时间 int pressedT = i==0? releaseTimes[i] : releaseTimes[i] - releaseTimes[i-1]; char currentKey = keysPressed[i]; //改题目后与原答案的区别 //--------------start-------------- // 如果找不到当前按键，则新建；找到，则累加已有时间并更新map if( pressedTime.find(currentKey) == pressedTime.end()) { pressedTime.insert(make_pair(currentKey, pressedT)); }else { pressedTime[currentKey] += pressedT; pressedT = pressedTime[currentKey]; } //--------------end-------------- if (pressedT &gt; maxTime) { result = currentKey; maxTime = pressedT; }else if(pressedT == maxTime) { if(currentKey &gt; result) { result = currentKey; } } } return result; }}; 注意事项map中使用find()去寻找key的时候，返回值不是key所对应的value，而是该数据所在的迭代器。所以如果map中不存在所查找的key，返回值会与 end() 相等。所以可以通过比较 find() 的返回值与 end()是否相等来判断该map中是否有查找的key值。","link":"/2022-b5f06120bfd8/"},{"title":"刷题笔记 - 递增的三元子序列","text":"题目给你一个整数数组nums ，判断这个数组中是否存在长度为 3 的递增子序列。 如果存在这样的三元组下标(i, j, k)且满足 i &lt; j &lt; k ，使得nums[i] &lt; nums[j] &lt; nums[k] ，返回 true ；否则，返回 false 。 示例示例 1：输入：nums = [1,2,3,4,5] 输出：true 解释：任何 i &lt; j &lt; k 的三元组都满足题意 示例 2：输入：nums = [5,4,3,2,1] 输出：false 解释：不存在满足题意的三元组 示例 3：输入：nums = [2,1,5,0,4,6] 输出：true 解释：三元组 (3, 4, 5) 满足题意，因为 nums[3] == 0 &lt; nums[4] == 4 &lt; nums[5] == 6 提示： $1 &lt;= nums.length &lt;= 5 * 105$ $-231 &lt;= nums[i] &lt;= 231 - 1$ 进阶：你能实现时间复杂度为 O(n) ，空间复杂度为 O(1) 的解决方案吗？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/increasing-triplet-subsequence 个人思路这道题我们可以使用贪心算法来实现进阶要求，并且算法思路很好理解。 我们首先需要初始化两个变量first和second来分别表示第一个和第二个数字。将first初始化为数组的第一个元素，将second初始化为无穷大。算法的思路就是在寻找第三个数的同时，不断的相对缩小第一个和第二个数字，使得第三个数字更容易满足条件。 我们从数组第二项开始遍历，若当前数字大于second，则说明找到了 first &lt; second &lt; temp，可以直接返回true；若当前数字大于 first 但小于second，则让second等于当前数字，使得second的值相对缩小（仍然满足first &lt; second）；若当前数字小于first，则让first等于当前数字，适当的缩小first的值（从而让second缩小的可能性提高，让整个递增数列满足更多的可能）。 若遍历结束后仍然没有满足的条件，则可以返回false，并结束算法。 该方法的时间复杂度为$O(n)$，n为数组长度；空间复杂度为O(1)，使用了常数个空间。 代码C++1234567891011121314151617181920212223class Solution {public: bool increasingTriplet(vector&lt;int&gt;&amp; nums) { int first { nums[0] }; int second { INT_MAX }; for(int i = 1; i &lt; nums.size(); i++) { int temp = nums[i]; if( temp &gt; second) { return true; } // 让第二个数相对变小，但大于第一个数 else if(temp &gt; first &amp;&amp; temp &lt; second) { second = temp; } // 让第一个数相对变小 else if(temp &lt; first) { first = temp; } } return false; }};","link":"/2022-2433e670fd25/"},{"title":"刷题笔记 - 至少是其他数字两倍的最大数","text":"题目给你一个整数数组 nums ，其中总是存在 唯一的 一个最大整数 。 请你找出数组中的最大元素并检查它是否 至少是数组中每个其他数字的两倍 。如果是，则返回 最大元素的下标 ，否则返回 -1 。 示例示例 1：输入：nums = [3,6,1,0] 输出：1 解释：6 是最大的整数，对于数组中的其他整数，6 大于数组中其他元素的两倍。6 的下标是 1 ，所以返回 1 。 示例 2：输入：nums = [1,2,3,4] 输出：-1 解释：4 没有超过 3 的两倍大，所以返回 -1 。 示例 3：输入：nums = [1] 输出：0 解释：因为不存在其他数字，所以认为现有数字 1 至少是其他数字的两倍。 提示： $1 &lt;= nums.length &lt;= 50$ $0 &lt;= nums[i] &lt;= 100$ $nums 中的最大元素是唯一的$ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/largest-number-at-least-twice-of-others 个人思路本题目十分简单，我们只需要三个变量在一次遍历中去记录最大值、次大值以及最大值的下标即可。 由于$0 &lt;= nums[i] &lt;= 100$，我们可以给最大值初始化为$nums[0]$，次大值 $bigger$和最大值下标$index$都初始化为$0$。这样即使数组只有一个元素，也不用额外进行判断。 之后遍历数组，如果遇到的元素大于最大值，则最大值赋值给次大值，当前元素赋值给最大值，这样每次便在更新最大值的同时保留次大值；但是不仅如此，我们同时还需要考虑另一种“当前元素比最大值小，但大于当前次大值”这样的情况，比如数组类似为$[1,2,9,6]$这样的情况，遍历到第三个元素的时候，最大值和次大值会更新为$9$和$2$，到了下一轮最大值不会更新，但是我们应该将次大值更新为$6$。 这样遍历完一边数组之后，我们就能得到最大值、次大值以及最大值的下标。之后我们即可比较$次大值* 2$是否不大于最大值即可确定返回值。（Ps：注意这里不要用最大值除以次大值是否大于等于2来判断，因为如果数组只有一个元素，或者次大值为0的时候，就会出现问题） 该方法时间复杂度为$O(n)$，$n$为数组长度；空间复杂度为$O(1)$，使用了常数个空间。 代码C++1234567891011121314151617181920212223class Solution {public: int dominantIndex(vector&lt;int&gt;&amp; nums) { // 最大的数 int biggest{ nums[0] }; // 第二大的数 int bigger{ 0 }; // 最大数的元素下标 int index { 0 }; for(int i = 1; i &lt; nums.size(); i++) { if( nums[i] &gt; biggest) { bigger = biggest; biggest = nums[i]; index = i; } else if (nums[i] &gt; bigger) { bigger = nums[i]; } } return bigger * 2 &lt;= biggest ? index : -1; }};","link":"/2022-b3b5a417bb30/"},{"title":"刷题笔记 - 计算力扣银行的钱","text":"题目Hercy 想要为购买第一辆车存钱。他 每天 都往力扣银行里存钱。 最开始，他在周一的时候存入 1 块钱。从周二到周日，他每天都比前一天多存入 1 块钱。在接下来每一个周一，他都会比 前一个周一 多存入 1 块钱。 给你 n ，请你返回在第 n 天结束的时候他在力扣银行总共存了多少块钱。 示例示例 1：输入：n = 4 输出：10 解释：第 4 天后，总额为 1 + 2 + 3 + 4 = 10 。 示例 2：输入：n = 10 输出：37 解释：第 10 天后，总额为 (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37 。注意到第二个星期一，Hercy 存入 2 块钱。 示例 3：输入：n = 20 输出：96 解释：第 20 天后，总额为 (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96 。 提示： 1 &lt;= n &lt;= 1000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/calculate-money-in-leetcode-bank 个人思路这一道题没有什么难点，也不用想得特别复杂，直接使用等差数列求和公式即可算出结果。 先求出完整交了多少周，可以直接使用n / 7求出；再通过n % 7取余求出最后一周交了几天。以周为单位的话，每周交的钱是等差数列，求和公式为： $$ S\\mathop{}\\nolimits_{n}=\\frac{n \\left( a\\mathop{}\\nolimits_{1}+a\\mathop{}\\nolimits_{n} \\right) }{2} = na\\mathop{}\\nolimits_{1}+\\frac{n \\left( n-1 \\right) }{2}d $$ 而一周里面七天交的钱一样可以使用等差数列直接求出；周一交的钱其实等于它的周数，第几周，周一就交多少。这样通过公式既能前几周总共交了多少钱，以及最后一周几天交的钱，两者相加即可得到总共交了多少钱。 该方法时间复杂度为$O(1)$，因为可以直接计算出来；空间复杂度也为$O(1)$，使用了常数个空间。 代码C++1234567891011121314151617class Solution {public: int totalMoney(int n) { // 最后一周交了几天 int days = n % 7; // 交了完整的周数 int weeks = n / 7; // 等差数列 (an + a1) * d / 2 int w1 = (1 + 7) * 7 / 2; int total { 0 }; // 等差数列 S = a1 * n + d * n(n-1)/2 total = w1 * weeks + 7 * weeks * ( weeks - 1 ) / 2; total += (weeks + 1) * days + 1 * days * ( days - 1 ) / 2; return total; }};","link":"/2022-b9405ae8f2ac/"},{"title":"刷题笔记 - 链表随机节点","text":"题目给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 被选中的概率一样 。 实现 Solution 类： Solution(ListNode head) 使用整数数组初始化对象。 int getRandom() 从链表中随机选择一个节点并返回该节点的值。链表中所有节点被选中的概率相等。 示例示例： 输入 [&quot;Solution&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;] [[[1, 2, 3]], [], [], [], [], []] 输出 [null, 1, 3, 2, 2, 3] 解释 Solution solution = new Solution([1, 2, 3]); solution.getRandom(); // 返回 1 solution.getRandom(); // 返回 3 solution.getRandom(); // 返回 2 solution.getRandom(); // 返回 2 solution.getRandom(); // 返回 3 // getRandom() 方法应随机返回 1、2、3中的一个，每个元素被返回的概率相等。 提示： 链表中的节点数在范围$ [1, 10^4]$ 内 $-10^4 &lt;= Node.val &lt;= 10^4$ 至多调用 getRandom 方法 $10^4$ 次 进阶： 如果链表非常大且长度未知，该怎么处理？ 你能否在不使用额外空间的情况下解决此问题？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/linked-list-random-node 个人思路我是在初始化的时候新建一个private数组把链表所有的元素记录进去，在获取随机元素的时候通过获取0 ~ array.size()范围的随机数作为索引，在返回数组相应元素即可。 该方法时间复杂度为$O(n)$，n为链表长度；空间复杂度为$O(n)$，因为需要建立长度为n的数组。 代码C++123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {private: vector&lt;int&gt; content;public: Solution(ListNode* head) { while(head != nullptr) { content.push_back(head-&gt;val); head = head-&gt;next; } } int getRandom() { int index = rand() % (content.size()); return content[index]; }};/** * Your Solution object will be instantiated and called as such: * Solution* obj = new Solution(head); * int param_1 = obj-&gt;getRandom(); */ 注意事项在获取随机数的时候，直接使用rand() % number，可以获得 0 ~ （number-1）范围的随机数（包括0和number-1）。所以如果要想获得1 ~ number范围的随机数，则可以使用rand() % number + 1，即可获得。","link":"/2022-82ee71e7145f/"},{"title":"刷题笔记 - 设计链表","text":"题目设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。 在链表类中实现这些功能： get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。 addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。 addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。 addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。 deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。 示例：MyLinkedList linkedList = new MyLinkedList(); linkedList.addAtHead(1); linkedList.addAtTail(3); linkedList.addAtIndex(1,2); //链表变为1-&gt; 2-&gt; 3 linkedList.get(1); //返回2 linkedList.deleteAtIndex(1); //现在链表是1-&gt; 3 linkedList.get(1); //返回3 提示： 所有val值都在 [1, 1000] 之内。 操作次数将在 [1, 1000] 之内。 请不要使用内置的 LinkedList 库。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/design-linked-list 个人思路首先需要设计好链表结点的结构，这个非常简单，单链表的话有一个val用来存放值，还有一个指向下一个结点的指针next，另外还需要建立两个构造函数来供新建结点的时候使用，一个是只传入val值并让结点默认指向空指针；另一个则是传入结点值和下一个结点。两个构造函数都十分方便。 根据个人习惯，在之前刷题时候操作量表的时候都会新建立个虚拟头结点，所以在 MyLinkedList这个类的构造函数里面我也默认设置了虚拟头结点，方便一些功能操作，虚拟头结点和链表的数量我将他们设置成私有变量。 接下来就是主要功能：读取、添加和删除。 读取：题目要求“通过index获得第index个结点”，但实际上看例子我们能发现其实我们还是按照首结点的索引为0这样来处理即可，即index是获取第index + 1个结点。清楚这一点，这个功能就十分简单。我们首先判锻传入的index值是否合法，如果大于 size - 1，直接按题目要求返回-1即可；否则若索引合法，我们便可通过循环递减的方式从虚拟头结点开始，当index递减到0的时候，下一个结点的值变为所需要的值。 添加：addAtHead() 和 addAtIndex(index, val) 这两个功能整体思路一致，都是添加链表结点。注意一点的是，添加结点的时候要先让新结点指向待添加位置的下一个结点，再让上一个结点指向新结点，如果反过来先将当前结点指向新结点，那下一个结点就丢了。 删除：删除结点核心就是在找到待删除结点前一个结点之后，新建个临时指针指向待删除的结点，再让待删除结点的前一个结点的next，指向next-&gt;next，最后再delete临时结点即可。 代码C++ （单链表）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394class MyLinkedList {public: // 链表结点结构 struct LinkedNode { int val; LinkedNode* next; LinkedNode(int val): val(val), next(nullptr) {}; LinkedNode(int val, LinkedNode* next): val(val), next(next) {}; }; // 初始化链表 MyLinkedList() { _dummyHead = new LinkedNode(0); _size = 0; } int get(int index) { // 索引无效返回 -1 if(index &gt; _size - 1) { return -1; }else { LinkedNode* temp = _dummyHead; while(index != 0) { temp = temp-&gt;next; index--; } return temp-&gt;next-&gt;val; } } void addAtHead(int val) { // 创建一个新结点并指向原来的头结点 LinkedNode* temp = new LinkedNode(val, _dummyHead-&gt;next); // 让虚拟头结点指向新建的结点 _dummyHead-&gt;next = temp; _size++; } void addAtTail(int val) { LinkedNode* temp = _dummyHead; // 让temp到结尾结点 while(temp-&gt;next != nullptr) { temp = temp-&gt;next; } temp-&gt;next = new LinkedNode(val); _size++; } void addAtIndex(int index, int val) { if(index &gt; _size){ return; } LinkedNode* temp = _dummyHead; while(index != 0) { temp = temp-&gt;next; index--; } // 当前temp在要插入结点的前一个位置 LinkedNode* added = new LinkedNode(val, temp-&gt;next); temp-&gt;next = added; _size++; } void deleteAtIndex(int index) { if(index &gt; _size - 1) { return; } LinkedNode* temp = _dummyHead; while(index != 0) { temp = temp-&gt;next; index--; } // 当前temp在要插入结点的前一个位置 LinkedNode* deleted = temp-&gt;next; temp-&gt;next = temp-&gt;next-&gt;next; delete deleted; _size--; }private: LinkedNode* _dummyHead; int _size;};/** * Your MyLinkedList object will be instantiated and called as such: * MyLinkedList* obj = new MyLinkedList(); * int param_1 = obj-&gt;get(index); * obj-&gt;addAtHead(val); * obj-&gt;addAtTail(val); * obj-&gt;addAtIndex(index,val); * obj-&gt;deleteAtIndex(index); */","link":"/2022-29b32ba9f4a4/"},{"title":"刷题笔记 - 力扣349、884、83、2000","text":"一、两个数组的交集题目给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。 示例示例 1：输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2] 示例 2：输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[9,4] 解释：[4,9] 也是可通过的 提示： 1 &lt;= nums1.length, nums2.length &lt;= 1000 0 &lt;= nums1[i], nums2[i] &lt;= 1000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/intersection-of-two-arrays 思路可以建立一个 map，通过哈希表的方式进行比对，分别遍历两个数组。在遍历第一个数组的时候，建立索引和对应的值，将值设为1，即便重复出现，依然设为1即可；遍历第二个数组的时候就可以对索引进行比对，如果存在并且为1，则说明在第一个数组中存在，即可筛选出来。 该方法时间复杂度为$O(n+m)$，$n, m$为两个数组的长度；空间复杂度为$O(n+m)$，空间取决于两个数组的长度。 代码C++1234567891011121314151617181920212223class Solution {public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { unordered_map&lt;int, int&gt; resultMap; vector&lt;int&gt; result; for(int i = 0; i &lt; nums1.size(); i++) { resultMap[nums1[i]] = 1; } for(int i = 0; i &lt; nums2.size(); i++) { if(resultMap.count(nums2[i]) != 0) { // 值为1说明没有统计过，否则证明是重复的数字 if(resultMap[nums2[i]] == 1){ result.push_back(nums2[i]); resultMap[nums2[i]]++; } } } return result; }}; 二、两句话中的不常见单词题目句子 是一串由空格分隔的单词。每个 单词 仅由小写字母组成。 如果某个单词在其中一个句子中恰好出现一次，在另一个句子中却 没有出现 ，那么这个单词就是 不常见的 。 给你两个 句子 s1 和 s2 ，返回所有 不常用单词 的列表。返回列表中单词可以按 任意顺序 组织。 示例示例 1：输入：s1 = &quot;this apple is sweet&quot;, s2 = &quot;this apple is sour&quot; 输出：[&quot;sweet&quot;,&quot;sour&quot;] 示例 2：输入：s1 = &quot;apple apple&quot;, s2 = &quot;banana&quot; 输出：[&quot;banana&quot;] 提示： 1 &lt;= s1.length, s2.length &lt;= 200 s1 和 s2 由小写英文字母和空格组成 s1 和 s2 都不含前导或尾随空格 s1 和 s2 中的所有单词间均由单个空格分隔 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/uncommon-words-from-two-sentences 思路这个题目可以理解成我们要获取两个句子中，总共只出现过一次的词语。那么我的思路是将两个字符串之间添加空格，合并成一个字符串，然后提取这个字符串中只出现过一次的词语。我们可以通过哈希表，在遍历字符串的同时进行统计，最后输出相应答案即可。 该方法时间复杂度和空间复杂度均为$O(n+m)$，跟两个字符串长度有关。 代码C++123456789101112131415161718192021222324252627282930313233class Solution {public: vector&lt;string&gt; uncommonFromSentences(string s1, string s2) { // 合并两个字符串 string total = s1 + &quot; &quot; + s2; string temp; // 建立一个map来统计次数 unordered_map&lt;string, int&gt; wordList; vector&lt;string&gt; result; for(int i = 0; i &lt; total.size(); i++) { if(total[i] != ' ') { temp += total[i]; } // 最后一个单词不要忘记统计 if(total[i] == ' ' || i == total.size()-1) { if(wordList.find(temp) != wordList.end()) { wordList[temp]++; }else{ wordList[temp] = 1; } temp = &quot;&quot;; } } for(const auto &amp; [key, value] : wordList) { if(value == 1) { result.push_back(key); } } return result; }}; 3: 三、删除排序链表中的重复元素题目给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。 示例示例 1： 输入：head = [1,1,2] 输出：[1,2] 示例 2： 输入：head = [1,1,2,3,3] 输出：[1,2,3] 提示： 链表中节点数目在范围 [0, 300] 内 -100 &lt;= Node.val &lt;= 100 题目数据保证链表已经按升序 排列 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list 思路该题目中有一个条件很重要，那就是该链表是已排序的链表。这意味着同样的元素都是放在一起的，不会出现穿插。那么我们就可以使用快慢双指针，十分简单的去判断。 首先，如果链表为空则直接返回即可，否则快慢指针都从首位开始； 快指针不断向后移动，如果当前快指针的元素与慢指针不相等，那么就让当前慢指针的下一个结点为当前快指针的节点，并让慢指针更新到快指针的位置，直到遍历完链表，否则慢指针不变，快指针继续向后移动； 如果快指针移动到了末尾且仍然与慢指针元素相等，则让慢指针的下一个节点指向空结点并结束循环。 该方法的时间复杂度为$O(n)$，n为链表长度；空间复杂度为$O(1)$，使用了常数个空间。 代码C++12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* deleteDuplicates(ListNode* head) { if(head == nullptr) return head; ListNode *slow = head; ListNode *fast = slow; while(slow-&gt;next != nullptr) { fast = fast-&gt;next; if(fast-&gt;val != slow-&gt;val) { slow-&gt;next = fast; slow = fast; } else if ( fast-&gt;val == slow-&gt;val &amp;&amp; fast-&gt;next == nullptr) { slow-&gt;next = nullptr; break; } else { continue; } } return head; }}; 四、反转单词前缀题目给你一个下标从 0 开始的字符串 word 和一个字符 ch 。找出 ch 第一次出现的下标 i ，反转 word 中从下标 0 开始、直到下标 i 结束（含下标 i ）的那段字符。如果 word 中不存在字符 ch ，则无需进行任何操作。 例如，如果 word = &quot;abcdefd&quot; 且 ch = &quot;d&quot; ，那么你应该 反转 从下标 0 开始、直到下标 3 结束（含下标 3 ）。结果字符串将会是 “ dcba efd” 。 返回 结果字符串 。 示例示例 1：输入：word = &quot;abcdefd&quot;, ch = &quot;d&quot; 输出：&quot;dcbaefd&quot; 解释：&quot;d&quot; 第一次出现在下标 3 。 反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 &quot;dcbaefd&quot; 。 示例 2：输入：word = &quot;xyxzxe&quot;, ch = &quot;z&quot; 输出：&quot;zxyxxe&quot; 解释：&quot;z&quot; 第一次也是唯一一次出现是在下标 3 。 反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 &quot;zxyxxe&quot; 。 示例 3：输入：word = &quot;abcd&quot;, ch = &quot;z&quot; 输出：&quot;abcd&quot; 解释：&quot;z&quot; 不存在于 word 中。 无需执行反转操作，结果字符串是 &quot;abcd&quot; 。 提示： 1 &lt;= word.length &lt;= 250 word 由小写英文字母组成 ch 是一个小写英文字母 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-prefix-of-word 思路方法一：使用栈基本思路就是遍历字符串，直到匹配到与ch相同的字符时跳出遍历。在遍历的同时将字符push到栈中。遍历结束后，将栈里面的元素逐个从word开头进行修改。最后返回 word 即可。 我在遍历的时候加了个 isIn 的布尔值进行记录，若是跳出结束的遍历，则证明字符串中有目标字符；否则证明遍历结束仍然不存在目标字符，这时候直接返回word即可。 该方法时间复杂度为$O(n)$，空间复杂度也为$O(n)$。 方法二：直接使用 STL库 函数这道题也可以直接使用 std::reverse() 来进行。 该方法时间复杂度为$O(n)$。 代码C++(方法一)1234567891011121314151617181920212223242526class Solution {public: string reversePrefix(string word, char ch) { stack&lt;char&gt; temp; // 记录word中是否含有 ch bool isIn{false}; for(int i = 0; i &lt; word.size(); i++) { if(word[i] != ch) { temp.push(word[i]); }else { temp.push(word[i]); isIn = true; break; } } int i = 0; while(!temp.empty() &amp;&amp; isIn == true) { word[i] = temp.top(); temp.pop(); i++; } return word; }}; C++(方法二)1234567891011class Solution {public: string reversePrefix(string word, char ch) { int index = word.find(ch); if(index != string::npos) { reverse(word.begin(), word.begin() + index + 1); } return word; }};","link":"/2022-45fe5716c69c/"},{"title":"刷题笔记 - 力扣1725，1748，2006，1984","text":"一、可以形成最大正方形的矩形数目题目给你一个数组 rectangles ，其中rectangles[i] = [li, wi]表示第i个矩形的长度为 li 、宽度为 wi 。 如果存在 k 同时满足 k &lt;= li 和 k &lt;= wi ，就可以将第i个矩形切成边长为 k 的正方形。例如，矩形 [4,6] 可以切成边长最大为 4 的正方形。 设 maxLen 为可以从矩形数组 rectangles 切分得到的 最大正方形 的边长。 请你统计有多少个矩形能够切出边长为 maxLen 的正方形，并返回矩形 **数目 **。 示例示例 1：输入：rectangles = [[5,8],[3,9],[5,12],[16,5]] 输出：3 解释：能从每个矩形中切出的最大正方形边长分别是 [5,3,5,5] 。 最大正方形的边长为 5 ，可以由 3 个矩形切分得到。 示例 2：输入：rectangles = [[2,3],[3,7],[4,3],[3,7]] 输出：3 提示： 1 &lt;= rectangles.length &lt;= 1000 rectangles[i].length == 2 1 &lt;= li, wi &lt;= 109 li != wi 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/number-of-rectangles-that-can-form-the-largest-square 思路题目看似有点绕，实际上可以理解为“找出每个数组中，最大较小值的个数”。我们只需要边遍历所有数组，边比较每个数组中较小的那个值是否大于或者等于当前记录的最大值：如果大于，则更新最大值并重新计数；若等于，则计数加一。最后返回计数即可。 该方法时间复杂度为$O(n)$，我们需要遍历整个数组；空间复杂度为$O(1)$，只是用了常数空间。 代码C++123456789101112131415161718class Solution {public: int countGoodRectangles(vector&lt;vector&lt;int&gt;&gt;&amp; rectangles) { int maxLen { 0 }; int maxK { 0 }; for(int i = 0; i &lt; rectangles.size(); i++) { int temp = min(rectangles[i][0], rectangles[i][1]); if(temp == maxK) { maxLen++; }else if (temp &gt; maxK) { maxK = temp; maxLen = 1; } } return maxLen; }}; 二、唯一元素的和题目给你一个整数数组 nums 。数组中唯一元素是那些只出现 恰好一次 的元素。 请你返回 nums 中唯一元素的 和 。 示例示例 1：输入：nums = [1,2,3,2] 输出：4 解释：唯一元素为 [1,3] ，和为 4 。 示例 2：输入：nums = [1,1,1,1,1] 输出：0 解释：没有唯一元素，和为 0 。 示例 3 ：输入：nums = [1,2,3,4,5] 输出：15 解释：唯一元素为 [1,2,3,4,5] ，和为 15 。 提示： 1 &lt;= nums.length &lt;= 100 1 &lt;= nums[i] &lt;= 100 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sum-of-unique-elements 思路我们可以通过建立一个哈希表，来对遇到的数字进行标记，实现一次遍历完成要求，具体方式如下： 遍历数组的时候查询哈希表中是否存在该数字，若不存在，则直接将当前数字与 result 相加，并在哈希表新建数字，对应的值为 -1； 若在哈希表中找到了数字，证明该数字不是唯一，需要减掉或者不加进来，那么我们可以通过哈希表中该数字对应的值来进行区分，将该值视为系数，想家的时候乘上系数即可。上一步骤中所说，初次遇到后将对应值设为**-1**，那么下次遇到的时候相乘完再相加即可实现减掉重复数值； 最后不管哈希表中原来数字对应的值是什么，只要在遍历过程中遇到了，先加完之后都将值改为0，以保证再遇到的时候相乘的系数是0，实现不加入结果的目的。 该方法时间复杂度为$O(n)$，空间复杂度也为$O(n)$。 代码C++123456789101112131415161718192021class Solution {public: int sumOfUnique(vector&lt;int&gt;&amp; nums) { unordered_map&lt;int, int&gt; check; int result { 0 }; for(int i = 0; i &lt; nums.size(); i++) { int current = nums[i]; // 若check里没有，则证明第一次遇到，result相加并添加 -1标记； if(check.find(current) == check.end()) { result += current; check[current] = -1; }else { // 若找到则直接与对应值相乘再与结果相加即可 result += current * check[current]; check[current] = 0; } } return result; }}; 三、差的绝对值为 K 的数对数目题目给你一个整数数组 nums 和一个整数 k ，请你返回数对 (i, j) 的数目，满足 i &lt; j 且 |nums[i] - nums[j]| == k 。 |x| 的值定义为： 如果 x &gt;= 0 ，那么值为 x 。如果 x &lt; 0 ，那么值为 -x 。 示例示例 1：输入：nums = [1,2,2,1], k = 1 输出：4 解释：差的绝对值为 1 的数对为： - [1,2,2,1] - [1,2,2,1] - [1,2,2,1] - [1,2,2,1] 示例 2：输入：nums = [1,3], k = 3 输出：0 解释：没有任何数对差的绝对值为 3 。 示例 3：输入：nums = [3,2,1,5,4], k = 2 输出：3 解释：差的绝对值为 2 的数对为： - [3,2,1,5,4] - [3,2,1,5,4] - [3,2,1,5,4] 提示： 1 &lt;= nums.length &lt;= 200 1 &lt;= nums[i] &lt;= 100 1 &lt;= k &lt;= 99 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/count-number-of-pairs-with-absolute-difference-k 思路我用的思路很简单直接，因为是要找满足条件的对子数量。那只要将数组中每个数字的个数统计出来存在哈希表中，再去读取每个数字满足条件的数字的个数，之后相乘再累加即可。如果数组中不存在满足的数字，则跳过即可。 该方法时间复杂度为$O(n)$，遍历了一边数组，并遍历了一边创建的哈希表，耗费$2n$时间；空间复杂度为$O(n)$，根据数组个数建立了一个哈希表。 代码C++12345678910111213141516171819202122232425262728class Solution {public: int countKDifference(vector&lt;int&gt;&amp; nums, int k) { int total { 0 }; // 记录nums中个数字的个数 unordered_map&lt;int, int&gt; numToCount; for(int i = 0; i &lt; nums.size(); i++) { int temp = nums[i]; if(numToCount.find(temp) != numToCount.end()) { numToCount[temp]++; }else { numToCount[temp] = 1; } } for(auto&amp; num : numToCount) { if(numToCount.find(num.first + k) == numToCount.end()){ continue; }else { total += num.second * numToCount[num.first + k]; } } return total; }}; 四、学生分数的最小差值题目给你一个 下标从 0 开始 的整数数组 nums ，其中 nums[i] 表示第 i 名学生的分数。另给你一个整数 k 。 从数组中选出任意 k 名学生的分数，使这 k 个分数间 最高分 和 最低分 的 差值 达到 **最小化 **。 返回可能的 最小差值 。 示例示例 1：输入：nums = [90], k = 1 输出：0 解释：选出 1 名学生的分数，仅有 1 种方法： - [90] 最高分和最低分之间的差值是 90 - 90 = 0 可能的最小差值是 0 示例 2：输入：nums = [9,4,1,7], k = 2 输出：2 解释：选出 2 名学生的分数，有 6 种方法： - [9,4,1,7] 最高分和最低分之间的差值是 9 - 4 = 5 - [9,4,1,7] 最高分和最低分之间的差值是 9 - 1 = 8 - [9,4,1,7] 最高分和最低分之间的差值是 9 - 7 = 2 - [9,4,1,7] 最高分和最低分之间的差值是 4 - 1 = 3 - [9,4,1,7] 最高分和最低分之间的差值是 7 - 4 = 3 - [9,4,1,7] 最高分和最低分之间的差值是 7 - 1 = 6 可能的最小差值是 2 提示： 1 &lt;= k &lt;= nums.length &lt;= 1000 0 &lt;= nums[i] &lt;= 105 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimum-difference-between-highest-and-lowest-of-k-scores 思路因为可以任意取k个数字，并要求最大最小差值最小，那么我们可以先进行排序，然后以k为一个滑动窗口，比较最大最小值的插值，取最小的即可。整体步骤分两步： 从小到大排序，直接使用C++的*sort()*排序即可； 接着使用滑动窗口，比较首位插值并返回最小值即可。 该方法时间复杂度为$O(nlogn)$，*sort()排序时间复杂度我$O(nlogn)$，滑动窗口则是$O(n)$；空间复杂度的话，查到的sort()*空间复杂度为$O(nlogn)$，因为用到了栈排序，所以整体空间复杂度为$O(nlogn)$。 代码C++1234567891011121314class Solution {public: int minimumDifference(vector&lt;int&gt;&amp; nums, int k) { int result { INT_MAX }; sort(nums.begin(), nums.end()); for(int i = 0; i + k &lt;= nums.size(); i++) { result = result &gt; nums[i+k-1] - nums[i] ? nums[i+k-1] - nums[i] : result; } return result; }};","link":"/2022-a85a69bb262d/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"力扣","slug":"力扣","link":"/tags/%E5%8A%9B%E6%89%A3/"},{"name":"Algorithm","slug":"ALGORITHM","link":"/tags/ALGORITHM/"},{"name":"Leetcode","slug":"LEETCODE","link":"/tags/LEETCODE/"},{"name":"书单","slug":"书单","link":"/tags/%E4%B9%A6%E5%8D%95/"},{"name":"Book List","slug":"BOOK-LIST","link":"/tags/BOOK-LIST/"}],"categories":[{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]}