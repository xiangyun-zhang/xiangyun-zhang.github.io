{"pages":[{"title":"","text":"Xiangyun’s Blog作为文章记录、更新和备份的私有库，只保证文章备份，博客框架、主题修改等记录在 blog 仓库中。","link":"/readme"},{"title":"","text":"","link":"/about/"}],"posts":[{"title":"2021年书单目录","text":"封面 信息 进度 《一句顶一万句》 作者：刘震云 出版社：长江文艺出版社 https://book.douban.com/subject/26877012/ - 《虚拟偶像爱朵露》 作者：[美] 威廉·吉布森 出版社：新星出版社 https://book.douban.com/subject/25725500/ - 《雪崩》 作者：[美] 尼尔·斯蒂芬森 出版社：四川科学技术出版社 https://book.douban.com/subject/27097409/ - 《富野由悠季的影像原则》 作者： [日] 富野由悠季 出版社：浙江大学出版社 https://book.douban.com/subject/35349490/ 第四章读完， 共十二章 《故事》 作者：[美] 罗伯特·麦基 出版社: 天津人民出版社 https://book.douban.com/subject/25976544/ 第一章在读","link":"/2021-59df9e5f512b/"},{"title":"Xiangyun&#39;s Blog 重新连接","text":"Hello world！Hello Hexo！ 兜兜转转，最后还是通过 Github Pages和 Hexo 搭建了个人博客。不过 Github Pages 中国大陆访问越来越不稳定了，也考虑把博客部署到 Gitee 上，有空再研究。 虽然放在 Github，但是博客并不打算局限于做技术博客，而是想写什么就写什么，风格不限、体裁不限、内容不限。 博客还有很多要完善的地方，即便是 Hexo 的静态页面，但是看上去还是有特别多的地方值得研究，慢慢来吧。 距离2022只剩下的小半年，但仍旧能够惊艳。","link":"/2021-9f238081d6ce/"},{"title":"算法笔记 - 无重复字符的最长子串","text":"题目给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 示例示例一输入: s = &quot;abcabcbb&quot; 输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例二输入: s = &quot;bbbbb&quot; 输出: 1 解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例三输入: s = &quot;pwwkew&quot; 输出: 3 解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 示例四输入: s = &quot;&quot; 输出: 0 提示： 0 &lt;= s.length &lt;= 5 * 104 s 由英文字母、数字、符号和空格组成 题目来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters 个人思路用一个变量记录“无重复字符的最长子串”的长度，再用两个变量作为子串的起始和末尾的位置。整个字符串逐个检查，若当前字符在子字符串中没有出现，则子串起始位置不变，末尾位置+1（末尾位置移到当前字符位置）；若当前字符在子串中出现，则与当前子串长度是否大于记录的“无重复字符的最长子串”的长度进行比较，判断是否要更新，再将子串起始位置更新至子串中当前字符重复字符的下一位，末尾位置+1（与另种情况一样）。 整个字符串遍历完成后，比较当前子串长度与记录的“无重复字符的最长子串”的长度，检查是否需要更新。最后返回最终的结果。 代码C++代码：123456789101112131415161718192021222324252627282930313233343536class Solution {public: int lengthOfLongestSubstring(string s) { // 判断是否为控制符串，若是直接返回0。 if(s.length() == 0) { return 0; } int start{0}; int end{0}; int maxLen{0}; for(int i = 0; i &lt; s.length(); i++) { end = i; // 由于其实是从0开始，左右这里的长度并不包含当前字符。 int len = end - start; string subString = s.substr(start, len); // 若当前字符已经在子串中出现过。 if(subString.find(s[i]) != string::npos) { if(maxLen &lt; len) { maxLen = len; } // 起始位置移至重复字符的下一位。 start = start + subString.find(s[i]) + 1; } } // 判断当前子串长度是否大于记录的最大长度，防止子串一直到结束都没有重复从而没有更新最大长度。 return maxLen &gt; (end - start +1) ? maxLen : (end - start +1); }}; 注意事项std::string 中size() 和 length() 没有区别，都是返回字节数。 string::npos 表示 string 的结束位置，find() 找不到指定值的时候会返回string::npos，所以可以用来判断是否找到所需的值。","link":"/2021-aa7d6baca413/"},{"title":"算法笔记 - 最长公共前缀","text":"题目编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例示例 1：输入：strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;] 输出：&quot;fl&quot; 示例 2：输入：strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;] 输出：&quot;&quot; 解释：输入不存在公共前缀。 提示： 1 &lt;= strs.length &lt;= 200 0 &lt;= strs[i].length &lt;= 200 strs[i] 仅由小写英文字母组成 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-common-prefix 个人思路 若传入数组长度为0或者仅有1个字符串，则直接返回 “” 或者该字符串； 之后便是将第一个字符串上的字符逐个设为待比较字符，遍历每个字符串逐个进行比较： 若比较过程中发现有空字符串则直接返回 “” ； 若发现当前比较的字符串中索引值超过某个字符串长度，则返回当前已确定的最长公共前缀。 发现有不同的字符也可以直接终止比较并返回当前已确定的最长公共前缀。 该方法说白了就是每个字符串逐个字符同时比较；所以另一种方法则是通过两个两个字符串逐个比较最长公共前缀，这里就不再赘述。 该方法时间复杂度为 O(mn)，m和n分别为传入数组的字符串个数和字符串的平均长度；空间复杂度为O(1)。 官方给出了另外两种方法，一个是分治一个是二分查找，但是这两种方法时间复杂度或空间复杂度并没有优势，且想法没有之前的方法直接，就不去过多关注了。但是自己写的代码还是可以参考改进的。 代码C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution {public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) { int num = strs.size(); if(num &lt;= 1) { // 若数组为0，返回&quot;&quot;；若为1，返回第一个字符串。 return num == 0 ? &quot;&quot;: strs[0]; } // 记录最长公共前缀 string lcStr{&quot;&quot;}; // 临时比较的字符 char temp{}; bool isEnd{false}; // 只用取第一个字符串的长度为最长循环次数即可 int length = strs[0].size(); for(int j = 0; j &lt; length; j++) { for(int i = 0; i &lt; num; i++) { if(strs[i] == &quot;&quot;) { return &quot;&quot;; } // 若是第一个字符串，则将该字符串相应位置的字符记为被判断字符，否则比较当前字符和被判断字符 if(i == 0) { temp = strs[i][j]; } else { // 若发现判断字符和当前字符不相等，直接结束循环返回当前已确定的前缀。 if(temp != strs[i][j]) { return lcStr; } // 若当前为数组的最后一个字符串且相等，则将被判断字符加入最长公共前缀中。 else if( i == num -1) { lcStr += temp; } } } } return lcStr; }}; C++（官方题解）12345678910111213141516171819class Solution {public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) { if (!strs.size()) { return &quot;&quot;; } int length = strs[0].size(); int count = strs.size(); for (int i = 0; i &lt; length; ++i) { char c = strs[0][i]; for (int j = 1; j &lt; count; ++j) { if (i == strs[j].size() || strs[j][i] != c) { return strs[0].substr(0, i); } } } return strs[0]; }};","link":"/2021-cd5b0f8c43a7/"},{"title":"算法笔记 - 罗马数字转整数","text":"题目罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。 示例示例一输入: s = &quot;III&quot; 输出: 3 示例二输入: s = &quot;IV&quot; 输出: 4 示例三输入: s = &quot;IX&quot; 输出: 9 示例四输入: s = &quot;LVIII&quot; 输出: 58 解释: L = 50, V= 5, III = 3. 示例五输入: s = &quot;MCMXCIV&quot; 输出: 1994 解释: M = 1000, CM = 900, XC = 90, IV = 4. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/roman-to-integer 个人思路从罗马数字字符串末尾开始向前判断，若为‘I，X，C’时则判断其右边位数的值，来进行累加或者累减。但是这个思路有点暴力破解，等于将每个条件都进行判断。而实际只需用按顺序判断前一个字符所代表的数字是否小于后一个字符即可，若小于则累减，否则累加。 代码C++代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution { public: int romanToInt(string s) { // 累加数字 int total{0}; for(int i=s.length()-1 ; i &gt;= 0; i--) { int isMinus{ 1 }; switch(s[i]) { case 'I': if(s[i+1] == 'V' || s[i+1] == 'X') { isMinus = -1; } total += isMinus * 1; break; case 'V': total += 5; break; case 'X': if(s[i+1] == 'L' || s[i+1] == 'C') { isMinus = -1; } total += isMinus * 10; break; case 'L': total += 50; break; case 'C': if(s[i+1] == 'D' || s[i+1] == 'M') { isMinus = -1; } total += isMinus * 100; break; case 'D': total += 500; break; case 'M': total += 1000; break; } } return total; } }; 官方题解C++代码123456789101112131415161718192021222324252627class Solution {private: unordered_map&lt;char, int&gt; symbolValues = { {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000}, };public: int romanToInt(string s) { int ans = 0; int n = s.length(); for (int i = 0; i &lt; n; ++i) { int value = symbolValues[s[i]]; if (i &lt; n - 1 &amp;&amp; value &lt; symbolValues[s[i + 1]]) { ans -= value; } else { ans += value; } } return ans; }};","link":"/2021-4dd8d59c8b20/"},{"title":"算法笔记 - 有效的括号","text":"题目给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 示例示例 1：输入：s = &quot;()&quot; 输出：true 示例 2：输入：s = &quot;()[]{}&quot; 输出：true 示例 3：输入：s = &quot;(]&quot; 输出：false 示例 4：输入：s = &quot;([)]&quot; 输出：false 示例 5：输入：s = &quot;{[]}&quot; 输出：true 提示： 1 &lt;= s.length &lt;= 104 s 仅由括号 ‘()[]{}’ 组成 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/valid-parentheses 个人思路看到题目之后很直接就联想到了使用栈来解决，因为每队括号必须闭合且按顺序，所以栈的后进先出很容易就可以比较右括号与最近的左括号是否匹配。 而因为括号成对出现，所以可以优先判断下字符串长度，如果为奇数则可以直接返回False。（题目已给出条件字符串不会为空） 在遍历字符串的时候，左括号可以依次 push 进栈中；遇到右括号时，则可以比较栈里最顶部的左括号是否匹配。 遍历结束后若栈为空，则说明所有括号都匹配，字符串有效。 该方法时间复杂度为 O(n)，空间复杂度为 O(n)。 代码C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution {public: bool isValid(string s) { // 若长度为奇数直接返回false; if((s.length())%2 != 0) { return false; } stack&lt;char&gt; a; for(int i = 0; i &lt; s.length(); i++) { char temp = s[i]; switch(temp) { case '(': a.push('('); break; case ')': if(a.empty() || a.top() != '(') { return false; } else { a.pop(); } break; case '[': a.push('['); break; case ']': if(a.empty() || a.top() != '[') { return false; } else { a.pop(); } break; case '{': a.push('{'); break; case '}': if(a.empty() || a.top() != '{') { return false; } else { a.pop(); } break; } } return a.empty(); }};","link":"/2021-a5555f2e2be4/"},{"title":"算法笔记 - 合并两个有序链表","text":"题目将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例示例 1：输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4] 示例 2：输入：l1 = [], l2 = [] 输出：[] 示例 3：输入：l1 = [], l2 = [0] 输出：[0] 提示： 两个链表的节点数目范围是 [0, 50] -100 &lt;= Node.val &lt;= 100 l1 和 l2 均按 非递减顺序 排列 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/merge-two-sorted-lists 个人思路简单暴力的方法，就是新建一个节点，然后逐一比较两个节点的大小，加到新建的这个节点后面。l1或l2也逐一后移，直到其中一个链表全部添加完（成空链），则退出循环并将另一个非空链表加到新建链表之后。该方法时间复杂度为O(n+m)，n，m为两个链表的长度；空间复杂度为O(1)。 代码C++123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { // 本来做了l1和l2的空链表判断，但是后面循环里面有了这个功能并处理了剩余链表，所以这里不需用再单独判断了。 // if(l1 == nullptr || l2 == nullptr) // { // return l1 == nullptr ? l2 : l1; // } // temp作为移动的节点将相应节点加到combine后面。 ListNode combine{}; ListNode *temp{ &amp;combine }; // 若两个链表都不为空，则比较两链表节点的大小，并加到combine后面。 while(l1 != nullptr &amp;&amp; l2 != nullptr) { if(l1-&gt;val &lt; l2-&gt;val) { temp-&gt;next = l1; l1 = l1-&gt;next; }else{ temp-&gt;next = l2; l2 = l2-&gt;next; } temp = temp-&gt;next; } // 剩下的链可以直接加到合成链的后面。 temp-&gt;next = l1==nullptr?l2:l1; return combine.next; }};","link":"/2021-11ff5ab6d926/"},{"title":"算法笔记 - 删除有序数组中的重复项","text":"题目给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 示例示例 1：输入：nums = [1,1,2] 输出：2, nums = [1,2] 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。 示例 2：输入：nums = [0,0,1,1,1,2,2,3,3,4] 输出：5, nums = [0,1,2,3,4] 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 提示： 0 &lt;= nums.length &lt;= 3 * 104 -104 &lt;= nums[i] &lt;= 104 nums 已按升序排列 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array 个人思路一开始的时候没有太读懂题目。其实题目意思就是将数组不重复的元素有序放在前面，并返回个数。接着答案会根据返回的个数输出数组的前n项。这也就是为什么我们返回的是数目，当答案输出的确是数组。 我们可以用两个指针来对数组进行修改：一个快指针进行数组遍历；另一个慢指针进行数组修改。快慢指针从第二个元素开始，快指针开始遍历数组。若快指针与前一个元素不同，则更新慢指针上的元素为快指针的元素，然后慢指针向后移动；若快指针与前一个元素相同，则继续遍历，慢指针不动。遍历完数组之后，快指针位于修改完的数组元素的下一位，而由于数组是从0开始作为索引。所以此时慢指针的数字也是数组无重复元素的个数（长度）。 Ps：更新的时候可以加一条判断，若快指针和慢指针不相等时候才更新慢指针元素。因为如果快慢指针相等，没必要进行元素更新；只有快慢指针不相等的时候，证明快慢指针中间出现重复元素，此时才需要更新慢指针元素。 该方法时间复杂度为 O(n)，空间复杂度为 O(1)。 代码C++12345678910111213141516171819202122232425262728class Solution {public: int removeDuplicates(vector&lt;int&gt;&amp; nums) { // 若数组长度为0，则直接返回 if(nums.size() == 0) { return 0; } int fast{1}; int slow{1}; for(slow = 1; slow &lt; nums.size(); slow++) { if(nums[slow] != nums[slow-1]) { // 若快慢指针处于同一位置，则不用复制，只有不处于同一位置时，才说明中间存在重复数组，需要更新。 if(fast != slow) { nums[fast] = nums[slow]; } fast++; } } return fast; }};","link":"/2021-b6458af3f313/"},{"title":"算法笔记 - 移除元素","text":"题目给你一个数组nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例示例 1：输入：nums = [3,2,2,3], val = 3 输出：2, nums = [2,2] 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 示例 2：输入：nums = [0,1,2,2,3,0,4,2], val = 2 输出：5, nums = [0,1,4,0,3] 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 提示： 0 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 50 0 &lt;= val &lt;= 100 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-element 个人思路跟昨天做的题目《删除有序数组中的重复项》的思路类似，这道题也使用双指针：一个指针在数组开头(start)，另个指针在数组末尾(end)。当 start 指针在 end 指针左边时，start 指针逐步右移，当 start 指针的元素与 val 的值相等时，与 end 指针元素互换，并让 end 指针左移一位；循环直到两个指针相遇( start - end &lt; 0)。 该方法时间复杂度为 O(n)，空间复杂度为 O(1)。 代码C++123456789101112131415161718192021222324252627class Solution {public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int len = nums.size(); if(len == 0) { return 0; } int start {0}; int end {len-1}; while(start - end &lt; 1) { if(nums[start] == val) { nums[start] = nums[end]; end--; }else { start++; } } return start; }};","link":"/2021-72f516a7ba25/"},{"title":"算法笔记 - 实现 strStr()","text":"题目实现 strStr() 函数。 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。 说明：当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。 示例示例 1：输入：haystack = &quot;hello&quot;, needle = &quot;ll&quot; 输出：2 示例 2：输入：haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot; 输出：-1 示例 3：输入：haystack = &quot;&quot;, needle = &quot;&quot; 输出：0 提示： 0 &lt;= haystack.length, needle.length &lt;= 5 * 104 haystack 和 needle 仅由小写英文字符组成 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/implement-strstr 个人思路暴力解法最直接想到的是暴力解法，这种解法思路简单但是耗时较长。 首先判断 needle 为0 和 haystack 为0这两种特殊情况。接着遍历haystack字符串，与needle字符串首字符进行比较，若相等，则继续匹配下一个字符。当出现不相等的时候跳出比较循环继续遍历haystack字符串。若haystack字符串遍历结束后依然没有匹配，则返回 -1。 该方法的时间复杂度为 O(mn)，空间复杂度为 O(1)。 代码C++（暴力解法）123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: int strStr(string haystack, string needle) { if(needle.length() == 0) { return 0; } if(haystack.length() == 0) { return -1; } bool isEnd{true}; for(int i = 0; i &lt; haystack.length(); i++) { // 若首字符像同，则开始比较后续的字符 if(haystack[i] == needle[0]) { for(int j = 1; j &lt; needle.length(); j++) { // 若发现出现不一样的字符，则跳出循环，并取消结束标记。 if(haystack[i+j] != needle[j]) { isEnd = false; break; } isEnd = true; } // 若结束，跳出循环，返回 if(isEnd) { return i; } } } return -1; }};","link":"/2021-81f924ed69a4/"}],"tags":[{"name":"书单","slug":"书单","link":"/tags/%E4%B9%A6%E5%8D%95/"},{"name":"Book List","slug":"BOOK-LIST","link":"/tags/BOOK-LIST/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"力扣","slug":"力扣","link":"/tags/%E5%8A%9B%E6%89%A3/"},{"name":"Algorithm","slug":"ALGORITHM","link":"/tags/ALGORITHM/"},{"name":"Leetcode","slug":"LEETCODE","link":"/tags/LEETCODE/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"}]}