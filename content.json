{"pages":[{"title":"","text":"Xiangyun’s Blog作为文章记录、更新和备份的私有库，只保证文章备份，博客框架、主题修改等记录在 blog 仓库中。","link":"/readme"},{"title":"","text":"","link":"/about/"}],"posts":[{"title":"2021年书单目录","text":"封面 信息 进度 《一句顶一万句》 作者：刘震云 出版社：长江文艺出版社 https://book.douban.com/subject/26877012/ - 《虚拟偶像爱朵露》 作者：[美] 威廉·吉布森 出版社：新星出版社 https://book.douban.com/subject/25725500/ - 《雪崩》 作者：[美] 尼尔·斯蒂芬森 出版社：四川科学技术出版社 https://book.douban.com/subject/27097409/ - 《富野由悠季的影像原则》 作者： [日] 富野由悠季 出版社：浙江大学出版社 https://book.douban.com/subject/35349490/ 第四章读完， 共十二章 《故事》 作者：[美] 罗伯特·麦基 出版社: 天津人民出版社 https://book.douban.com/subject/25976544/ 第一章在读","link":"/2021-59df9e5f512b/"},{"title":"Xiangyun&#39;s Blog 重新连接","text":"Hello world！Hello Hexo！ 兜兜转转，最后还是通过 Github Pages和 Hexo 搭建了个人博客。不过 Github Pages 中国大陆访问越来越不稳定了，也考虑把博客部署到 Gitee 上，有空再研究。 虽然放在 Github，但是博客并不打算局限于做技术博客，而是想写什么就写什么，风格不限、体裁不限、内容不限。 博客还有很多要完善的地方，即便是 Hexo 的静态页面，但是看上去还是有特别多的地方值得研究，慢慢来吧。 距离2022只剩下的小半年，但仍旧能够惊艳。","link":"/2021-9f238081d6ce/"},{"title":"刷题笔记 - 无重复字符的最长子串","text":"题目给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 示例示例一输入: s = &quot;abcabcbb&quot; 输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例二输入: s = &quot;bbbbb&quot; 输出: 1 解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例三输入: s = &quot;pwwkew&quot; 输出: 3 解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 示例四输入: s = &quot;&quot; 输出: 0 提示： 0 &lt;= s.length &lt;= 5 * 104 s 由英文字母、数字、符号和空格组成 题目来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters 个人思路用一个变量记录“无重复字符的最长子串”的长度，再用两个变量作为子串的起始和末尾的位置。整个字符串逐个检查，若当前字符在子字符串中没有出现，则子串起始位置不变，末尾位置+1（末尾位置移到当前字符位置）；若当前字符在子串中出现，则与当前子串长度是否大于记录的“无重复字符的最长子串”的长度进行比较，判断是否要更新，再将子串起始位置更新至子串中当前字符重复字符的下一位，末尾位置+1（与另种情况一样）。 整个字符串遍历完成后，比较当前子串长度与记录的“无重复字符的最长子串”的长度，检查是否需要更新。最后返回最终的结果。 代码C++代码：123456789101112131415161718192021222324252627282930313233343536class Solution {public: int lengthOfLongestSubstring(string s) { // 判断是否为控制符串，若是直接返回0。 if(s.length() == 0) { return 0; } int start{0}; int end{0}; int maxLen{0}; for(int i = 0; i &lt; s.length(); i++) { end = i; // 由于其实是从0开始，左右这里的长度并不包含当前字符。 int len = end - start; string subString = s.substr(start, len); // 若当前字符已经在子串中出现过。 if(subString.find(s[i]) != string::npos) { if(maxLen &lt; len) { maxLen = len; } // 起始位置移至重复字符的下一位。 start = start + subString.find(s[i]) + 1; } } // 判断当前子串长度是否大于记录的最大长度，防止子串一直到结束都没有重复从而没有更新最大长度。 return maxLen &gt; (end - start +1) ? maxLen : (end - start +1); }}; 注意事项std::string 中size() 和 length() 没有区别，都是返回字节数。 string::npos 表示 string 的结束位置，find() 找不到指定值的时候会返回string::npos，所以可以用来判断是否找到所需的值。","link":"/2021-aa7d6baca413/"},{"title":"刷题笔记 - 最长公共前缀","text":"题目编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例示例 1：输入：strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;] 输出：&quot;fl&quot; 示例 2：输入：strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;] 输出：&quot;&quot; 解释：输入不存在公共前缀。 提示： 1 &lt;= strs.length &lt;= 200 0 &lt;= strs[i].length &lt;= 200 strs[i] 仅由小写英文字母组成 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-common-prefix 个人思路 若传入数组长度为0或者仅有1个字符串，则直接返回 “” 或者该字符串； 之后便是将第一个字符串上的字符逐个设为待比较字符，遍历每个字符串逐个进行比较： 若比较过程中发现有空字符串则直接返回 “” ； 若发现当前比较的字符串中索引值超过某个字符串长度，则返回当前已确定的最长公共前缀。 发现有不同的字符也可以直接终止比较并返回当前已确定的最长公共前缀。 该方法说白了就是每个字符串逐个字符同时比较；所以另一种方法则是通过两个两个字符串逐个比较最长公共前缀，这里就不再赘述。 该方法时间复杂度为 O(mn)，m和n分别为传入数组的字符串个数和字符串的平均长度；空间复杂度为O(1)。 官方给出了另外两种方法，一个是分治一个是二分查找，但是这两种方法时间复杂度或空间复杂度并没有优势，且想法没有之前的方法直接，就不去过多关注了。但是自己写的代码还是可以参考改进的。 代码C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution {public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) { int num = strs.size(); if(num &lt;= 1) { // 若数组为0，返回&quot;&quot;；若为1，返回第一个字符串。 return num == 0 ? &quot;&quot;: strs[0]; } // 记录最长公共前缀 string lcStr{&quot;&quot;}; // 临时比较的字符 char temp{}; bool isEnd{false}; // 只用取第一个字符串的长度为最长循环次数即可 int length = strs[0].size(); for(int j = 0; j &lt; length; j++) { for(int i = 0; i &lt; num; i++) { if(strs[i] == &quot;&quot;) { return &quot;&quot;; } // 若是第一个字符串，则将该字符串相应位置的字符记为被判断字符，否则比较当前字符和被判断字符 if(i == 0) { temp = strs[i][j]; } else { // 若发现判断字符和当前字符不相等，直接结束循环返回当前已确定的前缀。 if(temp != strs[i][j]) { return lcStr; } // 若当前为数组的最后一个字符串且相等，则将被判断字符加入最长公共前缀中。 else if( i == num -1) { lcStr += temp; } } } } return lcStr; }}; C++（官方题解）12345678910111213141516171819class Solution {public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) { if (!strs.size()) { return &quot;&quot;; } int length = strs[0].size(); int count = strs.size(); for (int i = 0; i &lt; length; ++i) { char c = strs[0][i]; for (int j = 1; j &lt; count; ++j) { if (i == strs[j].size() || strs[j][i] != c) { return strs[0].substr(0, i); } } } return strs[0]; }};","link":"/2021-cd5b0f8c43a7/"},{"title":"刷题笔记 - 罗马数字转整数","text":"题目罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。 示例示例一输入: s = &quot;III&quot; 输出: 3 示例二输入: s = &quot;IV&quot; 输出: 4 示例三输入: s = &quot;IX&quot; 输出: 9 示例四输入: s = &quot;LVIII&quot; 输出: 58 解释: L = 50, V= 5, III = 3. 示例五输入: s = &quot;MCMXCIV&quot; 输出: 1994 解释: M = 1000, CM = 900, XC = 90, IV = 4. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/roman-to-integer 个人思路从罗马数字字符串末尾开始向前判断，若为‘I，X，C’时则判断其右边位数的值，来进行累加或者累减。但是这个思路有点暴力破解，等于将每个条件都进行判断。而实际只需用按顺序判断前一个字符所代表的数字是否小于后一个字符即可，若小于则累减，否则累加。 代码C++代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution { public: int romanToInt(string s) { // 累加数字 int total{0}; for(int i=s.length()-1 ; i &gt;= 0; i--) { int isMinus{ 1 }; switch(s[i]) { case 'I': if(s[i+1] == 'V' || s[i+1] == 'X') { isMinus = -1; } total += isMinus * 1; break; case 'V': total += 5; break; case 'X': if(s[i+1] == 'L' || s[i+1] == 'C') { isMinus = -1; } total += isMinus * 10; break; case 'L': total += 50; break; case 'C': if(s[i+1] == 'D' || s[i+1] == 'M') { isMinus = -1; } total += isMinus * 100; break; case 'D': total += 500; break; case 'M': total += 1000; break; } } return total; } }; 官方题解C++代码123456789101112131415161718192021222324252627class Solution {private: unordered_map&lt;char, int&gt; symbolValues = { {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000}, };public: int romanToInt(string s) { int ans = 0; int n = s.length(); for (int i = 0; i &lt; n; ++i) { int value = symbolValues[s[i]]; if (i &lt; n - 1 &amp;&amp; value &lt; symbolValues[s[i + 1]]) { ans -= value; } else { ans += value; } } return ans; }};","link":"/2021-4dd8d59c8b20/"},{"title":"刷题笔记 - 有效的括号","text":"题目给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 示例示例 1：输入：s = &quot;()&quot; 输出：true 示例 2：输入：s = &quot;()[]{}&quot; 输出：true 示例 3：输入：s = &quot;(]&quot; 输出：false 示例 4：输入：s = &quot;([)]&quot; 输出：false 示例 5：输入：s = &quot;{[]}&quot; 输出：true 提示： 1 &lt;= s.length &lt;= 104 s 仅由括号 ‘()[]{}’ 组成 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/valid-parentheses 个人思路看到题目之后很直接就联想到了使用栈来解决，因为每队括号必须闭合且按顺序，所以栈的后进先出很容易就可以比较右括号与最近的左括号是否匹配。 而因为括号成对出现，所以可以优先判断下字符串长度，如果为奇数则可以直接返回False。（题目已给出条件字符串不会为空） 在遍历字符串的时候，左括号可以依次 push 进栈中；遇到右括号时，则可以比较栈里最顶部的左括号是否匹配。 遍历结束后若栈为空，则说明所有括号都匹配，字符串有效。 该方法时间复杂度为 O(n)，空间复杂度为 O(n)。 代码C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution {public: bool isValid(string s) { // 若长度为奇数直接返回false; if((s.length())%2 != 0) { return false; } stack&lt;char&gt; a; for(int i = 0; i &lt; s.length(); i++) { char temp = s[i]; switch(temp) { case '(': a.push('('); break; case ')': if(a.empty() || a.top() != '(') { return false; } else { a.pop(); } break; case '[': a.push('['); break; case ']': if(a.empty() || a.top() != '[') { return false; } else { a.pop(); } break; case '{': a.push('{'); break; case '}': if(a.empty() || a.top() != '{') { return false; } else { a.pop(); } break; } } return a.empty(); }};","link":"/2021-a5555f2e2be4/"},{"title":"刷题笔记 - 合并两个有序链表","text":"题目将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例示例 1：输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4] 示例 2：输入：l1 = [], l2 = [] 输出：[] 示例 3：输入：l1 = [], l2 = [0] 输出：[0] 提示： 两个链表的节点数目范围是 [0, 50] -100 &lt;= Node.val &lt;= 100 l1 和 l2 均按 非递减顺序 排列 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/merge-two-sorted-lists 个人思路简单暴力的方法，就是新建一个节点，然后逐一比较两个节点的大小，加到新建的这个节点后面。l1或l2也逐一后移，直到其中一个链表全部添加完（成空链），则退出循环并将另一个非空链表加到新建链表之后。该方法时间复杂度为O(n+m)，n，m为两个链表的长度；空间复杂度为O(1)。 代码C++123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { // 本来做了l1和l2的空链表判断，但是后面循环里面有了这个功能并处理了剩余链表，所以这里不需用再单独判断了。 // if(l1 == nullptr || l2 == nullptr) // { // return l1 == nullptr ? l2 : l1; // } // temp作为移动的节点将相应节点加到combine后面。 ListNode combine{}; ListNode *temp{ &amp;combine }; // 若两个链表都不为空，则比较两链表节点的大小，并加到combine后面。 while(l1 != nullptr &amp;&amp; l2 != nullptr) { if(l1-&gt;val &lt; l2-&gt;val) { temp-&gt;next = l1; l1 = l1-&gt;next; }else{ temp-&gt;next = l2; l2 = l2-&gt;next; } temp = temp-&gt;next; } // 剩下的链可以直接加到合成链的后面。 temp-&gt;next = l1==nullptr?l2:l1; return combine.next; }};","link":"/2021-11ff5ab6d926/"},{"title":"刷题笔记 - 删除有序数组中的重复项","text":"题目给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 示例示例 1：输入：nums = [1,1,2] 输出：2, nums = [1,2] 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。 示例 2：输入：nums = [0,0,1,1,1,2,2,3,3,4] 输出：5, nums = [0,1,2,3,4] 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 提示： 0 &lt;= nums.length &lt;= 3 * 104 -104 &lt;= nums[i] &lt;= 104 nums 已按升序排列 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array 个人思路一开始的时候没有太读懂题目。其实题目意思就是将数组不重复的元素有序放在前面，并返回个数。接着答案会根据返回的个数输出数组的前n项。这也就是为什么我们返回的是数目，当答案输出的确是数组。 我们可以用两个指针来对数组进行修改：一个快指针进行数组遍历；另一个慢指针进行数组修改。快慢指针从第二个元素开始，快指针开始遍历数组。若快指针与前一个元素不同，则更新慢指针上的元素为快指针的元素，然后慢指针向后移动；若快指针与前一个元素相同，则继续遍历，慢指针不动。遍历完数组之后，快指针位于修改完的数组元素的下一位，而由于数组是从0开始作为索引。所以此时慢指针的数字也是数组无重复元素的个数（长度）。 Ps：更新的时候可以加一条判断，若快指针和慢指针不相等时候才更新慢指针元素。因为如果快慢指针相等，没必要进行元素更新；只有快慢指针不相等的时候，证明快慢指针中间出现重复元素，此时才需要更新慢指针元素。 该方法时间复杂度为 O(n)，空间复杂度为 O(1)。 代码C++12345678910111213141516171819202122232425262728class Solution {public: int removeDuplicates(vector&lt;int&gt;&amp; nums) { // 若数组长度为0，则直接返回 if(nums.size() == 0) { return 0; } int fast{1}; int slow{1}; for(slow = 1; slow &lt; nums.size(); slow++) { if(nums[slow] != nums[slow-1]) { // 若快慢指针处于同一位置，则不用复制，只有不处于同一位置时，才说明中间存在重复数组，需要更新。 if(fast != slow) { nums[fast] = nums[slow]; } fast++; } } return fast; }};","link":"/2021-b6458af3f313/"},{"title":"刷题笔记 - 移除元素","text":"题目给你一个数组nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例示例 1：输入：nums = [3,2,2,3], val = 3 输出：2, nums = [2,2] 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 示例 2：输入：nums = [0,1,2,2,3,0,4,2], val = 2 输出：5, nums = [0,1,4,0,3] 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 提示： 0 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 50 0 &lt;= val &lt;= 100 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-element 个人思路跟昨天做的题目《删除有序数组中的重复项》的思路类似，这道题也使用双指针：一个指针在数组开头(start)，另个指针在数组末尾(end)。当 start 指针在 end 指针左边时，start 指针逐步右移，当 start 指针的元素与 val 的值相等时，与 end 指针元素互换，并让 end 指针左移一位；循环直到两个指针相遇( start - end &lt; 0)。 该方法时间复杂度为 O(n)，空间复杂度为 O(1)。 代码C++123456789101112131415161718192021222324252627class Solution {public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int len = nums.size(); if(len == 0) { return 0; } int start {0}; int end {len-1}; while(start - end &lt; 1) { if(nums[start] == val) { nums[start] = nums[end]; end--; }else { start++; } } return start; }};","link":"/2021-72f516a7ba25/"},{"title":"刷题笔记 - 实现 strStr()","text":"题目实现 strStr() 函数。 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。 说明：当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。 示例示例 1：输入：haystack = &quot;hello&quot;, needle = &quot;ll&quot; 输出：2 示例 2：输入：haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot; 输出：-1 示例 3：输入：haystack = &quot;&quot;, needle = &quot;&quot; 输出：0 提示： 0 &lt;= haystack.length, needle.length &lt;= 5 * 104 haystack 和 needle 仅由小写英文字符组成 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/implement-strstr 个人思路暴力解法最直接想到的是暴力解法，这种解法思路简单但是耗时较长。 首先判断 needle 为0 和 haystack 为0这两种特殊情况。接着遍历haystack字符串，与needle字符串首字符进行比较，若相等，则继续匹配下一个字符。当出现不相等的时候跳出比较循环继续遍历haystack字符串。若haystack字符串遍历结束后依然没有匹配，则返回 -1。 该方法的时间复杂度为 O(mn)，空间复杂度为 O(1)。 代码C++（暴力解法）123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: int strStr(string haystack, string needle) { if(needle.length() == 0) { return 0; } if(haystack.length() == 0) { return -1; } bool isEnd{true}; for(int i = 0; i &lt; haystack.length(); i++) { // 若首字符像同，则开始比较后续的字符 if(haystack[i] == needle[0]) { for(int j = 1; j &lt; needle.length(); j++) { // 若发现出现不一样的字符，则跳出循环，并取消结束标记。 if(haystack[i+j] != needle[j]) { isEnd = false; break; } isEnd = true; } // 若结束，跳出循环，返回 if(isEnd) { return i; } } } return -1; }};","link":"/2021-81f924ed69a4/"},{"title":"刷题笔记 - 搜索插入位置","text":"题目给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为 O(log n) 的算法。 示例示例 1:输入: nums = [1,3,5,6], target = 5 输出: 2 示例 2:输入: nums = [1,3,5,6], target = 2 输出: 1 示例 3:输入: nums = [1,3,5,6], target = 7 输出: 4 示例 4:输入: nums = [1,3,5,6], target = 0 输出: 0 示例 5:输入: nums = [1], target = 0 输出: 0 提示: 1 &lt;= nums.length &lt;= 104 -104 &lt;= nums[i] &lt;= 104 nums 为无重复元素的升序排列数组 -104 &lt;= target &lt;= 104 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/search-insert-position 个人思路要求使用时间复杂度为 O(log n) 的算法，又因为数组是有序数组，很自然而言的想到二分法的思路。通过比较目标值与中间位置的值的大小，不断缩小范围进行比较： 若target 大于 mid 的值，则 left 变为 mid + 1；反之若 target 小于 mid 的值，则 right 变为 mid - 1；若 target 等于 mid 的值，则可以直接返回 mid 的值。循环直到出现 right &lt; left 为止，证明 target 是在 right 和 left 之间，则返回 right + 1 （即 left）作为插入位置即可。 通过表格就可以很直观的描述过程。 情况一： Round Index 0 1 2 3 4 5 target value mid 和 target 比较 1 Value 2 4 6 8 10 12 5 - l m r - target &lt; m ( 5 &lt; 6) =&gt; r = m - 1 2 Value 2 4 6 8 10 12 5 - l, m r - target &gt; m ( 5 &gt; 2) =&gt; l = m + 1 3 Value 2 4 6 8 10 12 5 - l, r, m - target &gt; m ( 5 &gt; 4) =&gt; l = m + 1 4 Value 2 4 6 8 10 12 3 - r l - r &lt; l =&gt; return r + 1;( return l ) 情况二： Round Index 0 1 2 3 4 5 target value mid 和 target 比较 1 Value 2 4 6 8 10 12 11 - l m r - target &gt; m ( 11 &gt; 6) =&gt; l = m + 1 2 Value 2 4 6 8 10 12 11 - l m r - target &gt; m ( 11 &gt; 10) =&gt; l = m + 1 3 Value 2 4 6 8 10 12 11 - l, r, m - target &lt; m ( 11 &lt; 12 ) =&gt; r = m - 1 4 Value 2 4 6 8 10 12 11 - r l - r &lt; l =&gt; return r + 1;( return l ) 情况三： Round Index 0 1 2 3 4 5 target value mid 和 target 比较 1 Value 2 4 6 8 10 12 8 - l m r - target &gt; m ( 8 &gt; 6) =&gt; l = m + 1 2 Value 2 4 6 8 10 12 8 - l m r - target&lt; m ( 8 &lt; 10) =&gt; r = m - 1 3 Value 2 4 6 8 10 12 8 - l, r, m - target == m =&gt; return m; ( m 则为 target 搜索到的位置) 该方法时间复杂度为 O(log n)，空间复杂度为 O(1)。 代码C++12345678910111213141516171819202122232425262728class Solution {public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) { int left{ 0 }; int right = nums.size() - 1; while(right &gt;= left) { int mid = (left + right) / 2; int midVal = nums[mid]; if( midVal == target) { return mid; } if( target &gt; midVal) { left = mid + 1; } else if( target &lt; midVal) { right = mid - 1; } } return left; }};","link":"/2021-feaef45bedf4/"},{"title":"刷题笔记 - 最大子数组和","text":"题目给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组 是数组中的一个连续部分。 示例示例 1：输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2：输入：nums = [1] 输出：1 示例 3：输入：nums = [5,4,-1,7,8] 输出：23 提示： 1 &lt;= nums.length &lt;= 105 -104 &lt;= nums[i] &lt;= 104 进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-subarray 个人思路如果数组长度为1，则直接返回该元素。 否则从第二个元素开始，若前一个元素大于0，则将当前元素与前一个元素相加，把值更新到当前元素。比较当前元素的值与最大值，若大于最大值，则更新最大值。直到数组遍历完比，返回最大值即可。 该方法时间复杂度为 O(n)，空间复杂度为 O(1)。 示例： Round 最大值 初始 -2 1 -3 4 -1 2 1 -5 4 -2 1 -2 1 -3 4 -1 2 1 -5 4 1 -2&lt;0 2 -2 1 -2 4 -1 2 1 -5 41 1 -3+1 3 -2 1 -2 4 -1 2 1 -5 1 4 -2&lt;0 4 -2 1 -2 4 3 2 1 -5 4 4 -1+4 5 -2 1 -2 4 3 5 1 -5 4 5 2+3 6 -2 1 -2 4 3 2 6 -5 4 6 1+5 7 -2 1 -2 4 3 2 6 1 4 6 -5+1 8 -2 1 -2 4 3 2 6 1 5 6 4+1 代码C++1234567891011121314151617181920212223242526272829class Solution {public: int maxSubArray(vector&lt;int&gt;&amp; nums) { // 若长度为1直接返回结果 if(nums.size() &lt; 2) { return nums[0]; } // 将结果预设为第一个元素的值 int result = nums[0]; for(int i = 1; i &lt; nums.size(); i++) { // 若前一个元素大于零，当前元素与前一个元素相加，更新到当前元素 if(nums[i - 1] &gt; 0) { nums[i] += nums[i - 1]; } // 更新完之后若当前元素大于result，则更新 result if(result &lt; nums[i]) { result = nums[i]; } } return result; }};","link":"/2021-f0ffa6620951/"},{"title":"刷题笔记 - 二分查找","text":"题目给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例示例 1:​ 输入: nums = [-1,0,3,5,9,12], target = 9​ 输出: 4​ 解释: 9 出现在 nums 中并且下标为 4 示例 2:​ 输入: nums = [-1,0,3,5,9,12], target = 2​ 输出: -1​ 解释: 2 不存在 nums 中因此返回 -1 提示： 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/binary-search 个人思路这道题其实就是“搜索插入位置”题目的基础班，就基本的二分查找。其方法思路我在之前的《刷题笔记 - 搜索插入位置》已经解释的非常详细了，唯一的区别就是该题因为只是查找，不用返回插入的坐标，在结束循环之前没有返回的话证明数组内没有目标值，最后的返回值为-1即可。 代码C++123456789101112131415161718192021222324252627class Solution {public: int search(vector&lt;int&gt;&amp; nums, int target) { int left{0}; int right = nums.size() - 1; while (right &gt;= left) { int mid = (right + left) / 2; int midVal = nums[mid]; // 如果中点与目标值相等，直接返回索引 if (target == midVal) { return mid; } if (target &gt; midVal) { left = mid + 1; } else if (target &lt; midVal) { right = mid - 1; } } // 循环结束仍未有返回值证明数组中不含目标值 return -1; }};","link":"/2021-1c6946f785d6/"},{"title":"刷题笔记 - 长度最小的子数组","text":"题目给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [$nums_l$, $nums_{l+1}$, …, $nums_{r-1}$, $nums_r$] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 示例示例 1：输入：target = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 示例 2：输入：target = 4, nums = [1,4,4] 输出：1 示例 3：输入：target = 11, nums = [1,1,1,1,1,1,1,1] 输出：0 提示： 1 &lt;= target &lt;= 109 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 105 进阶：如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimum-size-subarray-sum 个人思路我们可以利用类似双指针的思想，通过start和end两个指针建立一个滑动窗口。 start和end初始位置均在数组开头，首先移动end指针，开始构建窗口。当滑动窗口里面的子数组和大于等于target的时候，我们比较当前最小长度值来判断是否需要更新最小长度；之后end指针不动，移动start指针位置，并判断是否需要更新子数组最小长度，直到窗口内子数组和小于目标值，再继续先后移动end指针。直到整个数组遍历完毕。下面用表格来进行详细步骤演示，将会更加直观。 2 3 1 2 4 3 sum target length start, end 2 7 0 2 3 1 2 4 3 sum target length start end 5 7 0 2 3 1 2 4 3 sum target length start end 6 7 0 2 3 1 2 4 3 sum target length start end 8 7 4 2 3 1 2 4 3 sum target length start end 6 7 4 2 3 1 2 4 3 sum target length start end 10 7 4 2 3 1 2 4 3 sum target length start end 7 7 3 2 3 1 2 4 3 sum target length start end 6 7 3 2 3 1 2 4 3 sum target length start end 9 7 3 2 3 1 2 4 3 sum target length start end 7 7 2 该方法因为只用遍历一遍数组，所以时间复杂度为 O(n)，空间复杂度为 O(1)。 代码C++12345678910111213141516171819202122232425262728293031class Solution {public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) { // 活动窗口首位初试位置 int start{0}; int end{0}; // 长度最小连续子数组长度 int len{0}; // 窗口长度内子数组和 int sum{0}; for(int end = 0; end &lt; nums.size(); end++) { sum += nums[end]; while (sum &gt;= target) { int tempLen = end - start + 1; // 若当前子数组长度小于已知子数组长度 if(len == 0 || tempLen &lt; len) { len = tempLen; } // 窗口起始位置右移 sum -= nums[start]; start++; } } return len; }};","link":"/2021-389bb543d17d/"},{"title":"刷题笔记 - 螺旋矩阵","text":"题目给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。 示例示例 1： 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,2,3,6,9,8,7,4,5] 示例 2： 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] 输出：[1,2,3,4,8,12,11,10,9,5,6,7] 提示： m == matrix.length n == matrix[i].length 1 &lt;= m, n &lt;= 10 -100 &lt;= matrix[i][j] &lt;= 100 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/spiral-matrix 个人思路本题其实可以等价于将矩阵一圈一圈从外到内去遍历元素。上方是行不变列从左到右；右侧是列不变行从上到下；下方是行不变列从右到左；左侧是列不变行从下到上。所以可以设置四个变量分别表示每一圈上下左右位置，将元素在这之间遍历并添加到返回数组里面即可。值得注意的一点是，由于最后一圈会形成一个点、一列或者一行，所以在每次循环四边的时候在下方和左侧需要加一个判断，检查是否上下和左右有重合，若有，则不需要重复遍历。 时间复杂度为 $O(mn)$，每个元素都便利了一遍；空间复杂度为 $O(mn)$，建立了一个长度为 mn 的数组。 代码C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution {public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int row = matrix.size(); int col = matrix[0].size(); // 上下左右的索引值 int top = 0; int bottom = row - 1; int left = 0; int right = col - 1; vector&lt;int&gt; result; while ( left &lt;= right &amp;&amp; top &lt;= bottom) { // 顶部从左到右 for (int i = left; i &lt;= right; i++) { result.push_back(matrix[top][i]); } // 右边从上到下 for (int i = top + 1; i &lt;= bottom; i++) { result.push_back(matrix[i][right]); } if (left &lt; right &amp;&amp; top &lt; bottom) { // 底部从右到左 for (int i = right - 1; i &gt;= left; i--) { result.push_back(matrix[bottom][i]); } // 左边从下到上 for (int i = bottom - 1; i &gt; top; i--) { result.push_back(matrix[i][left]); } } // 顶部下移一层 top++; // 右边左移一位 right--; // 底部上移一层 bottom--; // 左边右移一位 left++; } return result; }};","link":"/2021-0459ab2ad0bb/"},{"title":"刷题笔记 - 螺旋矩阵II","text":"题目给你一个正整数 n ，生成一个包含 1 到 $n_2$ 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 示例示例 1： 输入：n = 3 输出：[[1,2,3],[8,9,4],[7,6,5]] 示例 2：输入：n = 1 输出：[[1]] 提示： 1 &lt;= n &lt;= 20 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/spiral-matrix-ii 个人思路这道题其实思路与《螺旋矩阵》一样，给一个正整数 n ，实际上就等于是矩阵行列为 n ，之后便是类似于《螺旋矩阵》中的遍历操作，只不过将获取矩阵元素换成赋值给矩阵相应位置。具体过程可以参考之前的思路。 该方法时间复杂度为 $O(n^2)$，空间复杂度也为$O(n^2)$，创建了一个 $n * n$ 的矩阵。 代码C++12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution {public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) { vector&lt;vector&lt;int&gt;&gt; matrix(n, vector&lt;int&gt;(n)); int top = 0; int bottom = n - 1; int left = 0; int right = n - 1; int i = 1; while (top &lt;= bottom &amp;&amp; left &lt;= right) { // 上方从左到右 for (int j = left; j &lt;= right; j++) { matrix[top][j] = i++; } // 右侧从上到下 for (int j = top + 1; j &lt;= bottom; j++) { matrix[j][right] = i++; } if (top &lt; bottom &amp;&amp; left &lt; right) { // 下方从右到左 for (int j = right - 1;j &gt;= left; j--) { matrix[bottom][j] = i++; } // 左侧从下到上 for (int j = bottom - 1; j &gt; top; j--) { matrix[j][left] = i++; } } top++; bottom--; left++; right--; } return matrix; }};","link":"/2021-a03717f51003/"},{"title":"刷题笔记 - 移除链表元素","text":"题目给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。 示例示例 1： 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5] 示例 2：输入：head = [], val = 1 输出：[] 示例 3：输入：head = [7,7,7,7], val = 7 输出：[] 提示： 列表中的节点数目在范围 [0, 104] 内 1 &lt;= Node.val &lt;= 50 0 &lt;= val &lt;= 50 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-linked-list-elements 个人思路题目并不难，只要一遍遍历一边对比找到与目标值一样的节点将它删除即可。我们判断每个节点的下一个节点是否是目标值，如果是的话，就将当前节点指向下下个节点，并将当前节点的下一个节点释放，即可完成删除。因为每次都是判断下一个节点，所以我们需要给头节点增加一个 0 节点当作初始节点方便进行判断。返回的时候我们返回这个 0 节点的下一位即是头节点。 该方法时间复杂度为 $O(n)$，因为要遍历所有的元素；空间复杂度为 $O(1)$，只用到了常数的空间存储。 代码C++12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* removeElements(ListNode* head, int val) { // 在head前新建一个节点 ListNode *zero = new ListNode(0, head); ListNode *current = zero; // 若下一个节点的值为目标值，则跳过该节点连接下下个节点；否则移到下一个节点继续判断。 while (current-&gt;next != nullptr) { if (current-&gt;next-&gt;val == val) { // 设置一个指针指向将被删的节点 ListNode *temp = current-&gt;next; current-&gt;next = current-&gt;next-&gt;next; // 释放被删除节点内存 delete temp; }else { current = current-&gt;next; } } return zero-&gt;next; }};","link":"/2021-2e8c5214b017/"},{"title":"刷题笔记 - 反转链表","text":"题目给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 示例示例 1： 输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1] 示例 2： 输入：head = [1,2] 输出：[2,1] 示例 3：输入：head = [] 输出：[] 提示： 链表中节点的数目范围是 [0, 5000] -5000 &lt;= Node.val &lt;= 5000 进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-linked-list 个人思路迭代该方法是迭代的方式完成反转，首先新建一个空指针作为结尾。之后一边遍历链表元素，一边用该元素创建新的链表元素，并将next指针指向之前的元素。这样便可完成链表反转。 该方法时间复杂度为 $O(n)$，因为需要遍历整个链表；空间复杂度也为$O(n)$，因为一边遍历一边新建元素，并没改变原来head为首的这条链表，而是新建了 $n$个元素组成了新的链表，使这条新链表与原来的链表相反。 如果可以优化一下代码，不建立新的链表，而是直接通过中间变量调换改变原来的链表，则可将空间复杂度变成了$O(1)$。 递归改题目递归思路的关键点在要将下一个节点递归下去的同时，对节点进行逆转操作。 结束条件为： 1(head == nullptr || head-&gt;next == nullptr) 以此判断链表已到末尾或者本身是空链表，返回当前head即可得到原来链表的末节点（即所需链表的首节点）； 将下一节点进行传递是： 1ListNode *current = reverseList(head-&gt;next); 因为最终我们需要的是逆转后链表的首节点，所以这里的 current 其实一直存储的就是该值，我们便需要在这段代码和最终 return current 这段代码之间，完成当前 head 和 head-&gt;next 的逆转。 逆转的代码如下： 12head-&gt;next-&gt;next = head;head-&gt;next = nullptr; 在将自身节点的下一个节点指向自己后，断开自己指向下一个节点的链接。即将 head 和 head-&gt;next 两个节点由原来的单链表，构建成双链表，再断开原先的指向，重新变回单链表。 该方法时间复杂度为 $O(n)$；空间复杂度为 $O(n)$，因为递归深度为$n$。 代码C++ （迭代，新建链表）12345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* reverseList(ListNode* head) { ListNode *result = nullptr; ListNode* current = head; while (current != nullptr) { ListNode *temp = new ListNode(current-&gt;val, result); result = temp; current = current-&gt;next; } return result; }}; C++ （迭代，优化空间复杂度）12345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* reverseList(ListNode* head) { ListNode* result = nullptr; ListNode* current = head; while (current != nullptr) { ListNode* temp = current-&gt;next; current-&gt;next = result; result = current; current = temp; } return result; }}; C++ （递归）12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* reverseList(ListNode* head) { if ( head == nullptr || head-&gt;next == nullptr) { return head; } // current 实际上一直是原来链表的最后一位元素，但是不断将 head-&gt;next 传下去进行操作 ListNode *current = reverseList(head-&gt;next); // 让当前head的下个元素指向自己，并断开当前head指向下个元素的链接 head-&gt;next-&gt;next = head; head-&gt;next = nullptr; return current; }};","link":"/2021-102da1183e5d/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"力扣","slug":"力扣","link":"/tags/%E5%8A%9B%E6%89%A3/"},{"name":"Algorithm","slug":"ALGORITHM","link":"/tags/ALGORITHM/"},{"name":"Leetcode","slug":"LEETCODE","link":"/tags/LEETCODE/"},{"name":"书单","slug":"书单","link":"/tags/%E4%B9%A6%E5%8D%95/"},{"name":"Book List","slug":"BOOK-LIST","link":"/tags/BOOK-LIST/"}],"categories":[{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"}]}